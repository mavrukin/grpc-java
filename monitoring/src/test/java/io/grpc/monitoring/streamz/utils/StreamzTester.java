// Copyright 2010 Google Inc. All Rights Reserved.
// Generated by generate.py

package io.grpc.monitoring.streamz.utils;

import com.google.common.base.Function;
import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;
import io.grpc.monitoring.streamz.Counter0;
import io.grpc.monitoring.streamz.Counter1;
import io.grpc.monitoring.streamz.Counter10;
import io.grpc.monitoring.streamz.Counter2;
import io.grpc.monitoring.streamz.Counter3;
import io.grpc.monitoring.streamz.Counter4;
import io.grpc.monitoring.streamz.Counter5;
import io.grpc.monitoring.streamz.Counter6;
import io.grpc.monitoring.streamz.Counter7;
import io.grpc.monitoring.streamz.Counter8;
import io.grpc.monitoring.streamz.Counter9;
import io.grpc.monitoring.streamz.Distribution;
import io.grpc.monitoring.streamz.EventMetric0;
import io.grpc.monitoring.streamz.EventMetric1;
import io.grpc.monitoring.streamz.EventMetric10;
import io.grpc.monitoring.streamz.EventMetric2;
import io.grpc.monitoring.streamz.EventMetric3;
import io.grpc.monitoring.streamz.EventMetric4;
import io.grpc.monitoring.streamz.EventMetric5;
import io.grpc.monitoring.streamz.EventMetric6;
import io.grpc.monitoring.streamz.EventMetric7;
import io.grpc.monitoring.streamz.EventMetric8;
import io.grpc.monitoring.streamz.EventMetric9;
import io.grpc.monitoring.streamz.Field;
import io.grpc.monitoring.streamz.GenericMetric;
import io.grpc.monitoring.streamz.Metric0;
import io.grpc.monitoring.streamz.Metric1;
import io.grpc.monitoring.streamz.Metric10;
import io.grpc.monitoring.streamz.Metric2;
import io.grpc.monitoring.streamz.Metric3;
import io.grpc.monitoring.streamz.Metric4;
import io.grpc.monitoring.streamz.Metric5;
import io.grpc.monitoring.streamz.Metric6;
import io.grpc.monitoring.streamz.Metric7;
import io.grpc.monitoring.streamz.Metric8;
import io.grpc.monitoring.streamz.Metric9;
import io.grpc.monitoring.streamz.MetricFactory;
import io.grpc.monitoring.streamz.VirtualMetric0;
import io.grpc.monitoring.streamz.VirtualMetric1;
import io.grpc.monitoring.streamz.VirtualMetric2;
import io.grpc.monitoring.streamz.VirtualMetric3;
import io.grpc.monitoring.streamz.VirtualMetric4;
import io.grpc.monitoring.streamz.VirtualMetric5;
import io.grpc.monitoring.streamz.VirtualMetric6;
import io.grpc.monitoring.streamz.VirtualMetric7;
import io.grpc.ManagedChannel;
// import com.google.net.rpc3.client.RpcChannel;
// import com.google.net.rpc3.client.RpcStubParameters;

import java.util.Map;

import javax.annotation.Generated;

/**
 * Utility for testing that {@code Metric}s are updated appropriately.
 * StreamzTester can test values of metrics either in-process, or in a
 * remote process, using {@link RemoteMetricReader}.
 *
 * <p>Additional documentation can be found at the Google Site at the <a href=
 * "https://sites.google.com/a/google.com/monarch-users/development/streamz-java-testing-cookbook">
 * Streamz Java Testing API</a>
 *
 * @author ecurran@google.com (Eoin Curran)
 */
@Generated(value = "generate.py")
public class StreamzTester {

  private final Map<Class<? extends Enum<?>>, Function<String, ? extends Enum>> enumTranslators =
      Maps.newIdentityHashMap();
  private final MetricReader reader;

  /**
   * Creates a tester using a supplied MetricReader.
   */
  private StreamzTester(MetricReader reader) {
    this.reader = reader;
  }

  /**
   * Creates a tester, using streamz values in-process.
   */
  private StreamzTester() {
    this(new LocalMetricReader());
  }

  /**
   * Creates a tester, using streamz values in-process created by the supplied factory.
   */
  private StreamzTester(MetricFactory factory) {
    this(new LocalMetricReader(factory));
  }

  /**
   * Creates a StreamzTester that speaks to the Stubby service defined by the supplied serverSpec.
   */
  public static StreamzTester createRemoteTester(String serverSpec) {
    return new StreamzTester(new RemoteMetricReader(serverSpec));
  }

  /**
   * Creates a StreamzTester that speaks to the Stubby service at the supplied host and port.
   */
  public static StreamzTester createRemoteTester(String host, int port) {
    return new StreamzTester(new RemoteMetricReader(host, port));
  }

  /**
   * Creates a StreamzTester that speaks to the Stubby service on the supplied channel.
   */
  public static StreamzTester createRemoteTester(ManagedChannel channel) {
    return new StreamzTester(new RemoteMetricReader(channel));
  }

  /**
   * Creates a StreamzTester that speaks to the in-process metrics created by the supplied factory.
   *
   * @see MetricFactory
   * @see io.grpc.monitoring.streamz.TestMetricFactory
   */
  public static StreamzTester createLocalTester(MetricFactory factory) {
    return new StreamzTester(new LocalMetricReader(factory));
  }

  /**
   * Creates a StreamzTester that speaks to the in-process metrics created by the default factory.
   *
   * @see MetricFactory
   * @see MetricFactory#getDefault()
   */
  public static StreamzTester createLocalTesterForDefaultFactory() {
    return new StreamzTester();
  }

  /**
   * Map an enum to a class that restores values to their original enum type.
   *
   * <p>In most cases, it's possible to restore the original enum value from a snapshot by
   * using the inverse of the Enum's {@code toString} method. However in the case where the
   * specific enum class overrides toString, the enum can't be reverse identified. In those cases,
   * the tester can provide an inversion function, turning Strings to their original enum
   * values.
   *
   * <p>Keep in mind that this API applies to metric <i>values</i> only, and does not
   * apply to metric fields. Enum fields are dealt with using {@link
   * io.grpc.monitoring.streamz.Field#ofEnumAsString(Class, String)}.
   *
   * @param cls the enum class to be supported. Calling this method repeatedly with the same
   * class will replace all previously defined translators.
   * @param function a function that restores an enum from its {@link Enum#toString()} form.
   * Passing {@code null} indicates that the class has no translator.
   *
   * @return this object, allowing method chaining.
   */
  public <T extends Enum<T>> StreamzTester addEnumTranslator(
      Class<T> cls, Function<String, T> function) {
    enumTranslators.put(cls, function);
    return this;
  }

  /**
   * Get the enum translator assocaited with this tester.
   */
  @SuppressWarnings("unchecked") // addEnumTranslator ensures the typecast is safe.
  <T extends Enum<T>> Function<String, T> getEnumTranslator(Class<T> c) {
    return (Function<String, T>) enumTranslators.get(c);
  }

  /**
   * Reads a snapshot of Streamz metrics matching the given pattern.
   *
   * @param pattern If pattern ends in a '/', then it will match all metrics
   *     with that prefix. Otherwise it matches metrics with exactly that name.
   */
  public StreamzSnapshot getSnapshot(String pattern) {
    return reader.snapshot(pattern);
  }

  /**
   * Reads a snapshot of all Streamz metrics.
   */
  public StreamzSnapshot getFullSnapshot() {
    return reader.snapshotAll();
  }

  /**
   * Creates a metric tester for a named metric.
   *
   * <p> <b>Important</b> When the metric's value type
   * {@code Integer}, use {@code Long} here. That's because the collection mechanism doesn't
   * distinguish between 32- and 64-bit integers, so the fact that the metric was an {@code
   * Integer} is long gone by the time this reference gets a hold of it.
   *
   * @param metricName name of the metric to create a tester for.
   * @param valueType the value type of the metric.
   */
  public <V> MetricReferenceTester0<V> metricReference(
      String metricName,
      Class<V> valueType) {
    return new MetricReferenceTester0<V>(this, metricName, valueType);
  }

  /**
   * Creates a metric tester for a single-cell event metric.
   *
   * @param metricName The name of the metric to create the tester for.
   */
  public MetricReferenceTester0<Distribution> eventMetricReference(
      String metricName) {
    return new MetricReferenceTester0<Distribution>(
        this, metricName, Distribution.class);
  }

  private <V, M extends GenericMetric<V, M>> MetricReferenceTester0<V> referenceToImpl0(
      GenericMetric<V, M> metric) {
    return new MetricReferenceTester0<V>(this, metric.getName(), metric.getValueType());
  }

  /**
   * Creates a metric tester for a specific metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <V> MetricReferenceTester0<V> referenceTo(Metric0<V> metric) {
    return referenceToImpl0(metric);
  }

  /**
   * Creates a metric tester for a specific event metric.
   *
   * @param metric the metric to create a tester for.
   */
  public MetricReferenceTester0<Distribution> referenceTo(EventMetric0 metric) {
    // Can't use referenceToImpl because getUnderlyingMetric() is protected.
    return new MetricReferenceTester0<Distribution>(this, metric.getName(), Distribution.class);
  }

  /**
   * Creates a metric tester for a specific counter.
   *
   * @param metric the metric to create a tester for.
   */
  public MetricReferenceTester0<Long> referenceTo(Counter0 metric) {
    return referenceToImpl0(metric);
  }

  /**
   * Creates a metric tester for a specific virtual metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <V> MetricReferenceTester0<V> referenceTo(VirtualMetric0<V> metric) {
    return referenceToImpl0(metric);
  }


  /**
   * Creates a reference to an one-dimensional metric.
   *
   * <p> <b>Important</b> When the metric's value type
   * {@code Integer}, use {@code Long} here. That's because the collection mechanism doesn't
   * distinguish between 32- and 64-bit integers, so the fact that the metric was an {@code
   * Integer} is long gone by the time this reference gets a hold of it.
   *
   * @param metricName the name of the metric.
   * @param valueType the value type of the metric.
   * @param field1 The first field
   */
  public <F1, V>
  MetricReferenceTester1<F1, V> metricReference(
      String metricName,
      Class<V> valueType,
      Field<F1> field1) {
    return new MetricReferenceTester1<F1, V>(
        this, metricName, valueType,
        field1);
  }

  /**
   * Creates a reference to an one-dimensional event metric.
   *
   * @param metricName The name of the metric.
   * @param field1 The first field
   */
  public <F1>
  MetricReferenceTester1<F1, Distribution> eventMetricReference(
      String metricName,
      Field<F1> field1) {
    return new MetricReferenceTester1<F1, Distribution>(
        this, metricName, Distribution.class,
        field1);
  }

  private <F1, V, M extends GenericMetric<V, M>>
  MetricReferenceTester1<F1, V> referenceToImpl1(
      GenericMetric<V, M> metric) {
    return new MetricReferenceTester1<F1, V>(
      this, metric.getName(), metric.getValueType(),
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, V>
  MetricReferenceTester1<F1, V> referenceTo(
      Metric1<F1, V> metric) {
    return referenceToImpl1(metric);
  }

  /**
   * Creates a metric tester for a specific event metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1>
  MetricReferenceTester1<F1, Distribution> referenceTo(
      EventMetric1<F1> metric) {
    // Can't use referenceToImpl because getUnderlyingMetric() is protected.
    return new MetricReferenceTester1<F1, Distribution>(
      this, metric.getName(), Distribution.class,
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific counter.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1>
  MetricReferenceTester1<F1, Long> referenceTo(
      Counter1<F1> metric) {
    return referenceToImpl1(metric);
  }
  /**
   * Creates a reference to an two-dimensional metric.
   *
   * <p> <b>Important</b> When the metric's value type
   * {@code Integer}, use {@code Long} here. That's because the collection mechanism doesn't
   * distinguish between 32- and 64-bit integers, so the fact that the metric was an {@code
   * Integer} is long gone by the time this reference gets a hold of it.
   *
   * @param metricName the name of the metric.
   * @param valueType the value type of the metric.
   * @param field1 The first field
   * @param field2 The second field
   */
  public <F1, F2, V>
  MetricReferenceTester2<F1, F2, V> metricReference(
      String metricName,
      Class<V> valueType,
      Field<F1> field1,
      Field<F2> field2) {
    return new MetricReferenceTester2<F1, F2, V>(
        this, metricName, valueType,
        field1,
            field2);
  }

  /**
   * Creates a reference to an two-dimensional event metric.
   *
   * @param metricName The name of the metric.
   * @param field1 The first field
   * @param field2 The second field
   */
  public <F1, F2>
  MetricReferenceTester2<F1, F2, Distribution> eventMetricReference(
      String metricName,
      Field<F1> field1,
      Field<F2> field2) {
    return new MetricReferenceTester2<F1, F2, Distribution>(
        this, metricName, Distribution.class,
        field1,
            field2);
  }

  private <F1, F2, V, M extends GenericMetric<V, M>>
  MetricReferenceTester2<F1, F2, V> referenceToImpl2(
      GenericMetric<V, M> metric) {
    return new MetricReferenceTester2<F1, F2, V>(
      this, metric.getName(), metric.getValueType(),
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, V>
  MetricReferenceTester2<F1, F2, V> referenceTo(
      Metric2<F1, F2, V> metric) {
    return referenceToImpl2(metric);
  }

  /**
   * Creates a metric tester for a specific event metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2>
  MetricReferenceTester2<F1, F2, Distribution> referenceTo(
      EventMetric2<F1, F2> metric) {
    // Can't use referenceToImpl because getUnderlyingMetric() is protected.
    return new MetricReferenceTester2<F1, F2, Distribution>(
      this, metric.getName(), Distribution.class,
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific counter.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2>
  MetricReferenceTester2<F1, F2, Long> referenceTo(
      Counter2<F1, F2> metric) {
    return referenceToImpl2(metric);
  }
  /**
   * Creates a reference to an three-dimensional metric.
   *
   * <p> <b>Important</b> When the metric's value type
   * {@code Integer}, use {@code Long} here. That's because the collection mechanism doesn't
   * distinguish between 32- and 64-bit integers, so the fact that the metric was an {@code
   * Integer} is long gone by the time this reference gets a hold of it.
   *
   * @param metricName the name of the metric.
   * @param valueType the value type of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   */
  public <F1, F2, F3, V>
  MetricReferenceTester3<F1, F2, F3, V> metricReference(
      String metricName,
      Class<V> valueType,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3) {
    return new MetricReferenceTester3<F1, F2, F3, V>(
        this, metricName, valueType,
        field1,
            field2,
            field3);
  }

  /**
   * Creates a reference to an three-dimensional event metric.
   *
   * @param metricName The name of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   */
  public <F1, F2, F3>
  MetricReferenceTester3<F1, F2, F3, Distribution> eventMetricReference(
      String metricName,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3) {
    return new MetricReferenceTester3<F1, F2, F3, Distribution>(
        this, metricName, Distribution.class,
        field1,
            field2,
            field3);
  }

  private <F1, F2, F3, V, M extends GenericMetric<V, M>>
  MetricReferenceTester3<F1, F2, F3, V> referenceToImpl3(
      GenericMetric<V, M> metric) {
    return new MetricReferenceTester3<F1, F2, F3, V>(
      this, metric.getName(), metric.getValueType(),
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, V>
  MetricReferenceTester3<F1, F2, F3, V> referenceTo(
      Metric3<F1, F2, F3, V> metric) {
    return referenceToImpl3(metric);
  }

  /**
   * Creates a metric tester for a specific event metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3>
  MetricReferenceTester3<F1, F2, F3, Distribution> referenceTo(
      EventMetric3<F1, F2, F3> metric) {
    // Can't use referenceToImpl because getUnderlyingMetric() is protected.
    return new MetricReferenceTester3<F1, F2, F3, Distribution>(
      this, metric.getName(), Distribution.class,
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific counter.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3>
  MetricReferenceTester3<F1, F2, F3, Long> referenceTo(
      Counter3<F1, F2, F3> metric) {
    return referenceToImpl3(metric);
  }
  /**
   * Creates a reference to an four-dimensional metric.
   *
   * <p> <b>Important</b> When the metric's value type
   * {@code Integer}, use {@code Long} here. That's because the collection mechanism doesn't
   * distinguish between 32- and 64-bit integers, so the fact that the metric was an {@code
   * Integer} is long gone by the time this reference gets a hold of it.
   *
   * @param metricName the name of the metric.
   * @param valueType the value type of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   */
  public <F1, F2, F3, F4, V>
  MetricReferenceTester4<F1, F2, F3, F4, V> metricReference(
      String metricName,
      Class<V> valueType,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4) {
    return new MetricReferenceTester4<F1, F2, F3, F4, V>(
        this, metricName, valueType,
        field1,
            field2,
            field3,
            field4);
  }

  /**
   * Creates a reference to an four-dimensional event metric.
   *
   * @param metricName The name of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   */
  public <F1, F2, F3, F4>
  MetricReferenceTester4<F1, F2, F3, F4, Distribution> eventMetricReference(
      String metricName,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4) {
    return new MetricReferenceTester4<F1, F2, F3, F4, Distribution>(
        this, metricName, Distribution.class,
        field1,
            field2,
            field3,
            field4);
  }

  private <F1, F2, F3, F4, V, M extends GenericMetric<V, M>>
  MetricReferenceTester4<F1, F2, F3, F4, V> referenceToImpl4(
      GenericMetric<V, M> metric) {
    return new MetricReferenceTester4<F1, F2, F3, F4, V>(
      this, metric.getName(), metric.getValueType(),
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, V>
  MetricReferenceTester4<F1, F2, F3, F4, V> referenceTo(
      Metric4<F1, F2, F3, F4, V> metric) {
    return referenceToImpl4(metric);
  }

  /**
   * Creates a metric tester for a specific event metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4>
  MetricReferenceTester4<F1, F2, F3, F4, Distribution> referenceTo(
      EventMetric4<F1, F2, F3, F4> metric) {
    // Can't use referenceToImpl because getUnderlyingMetric() is protected.
    return new MetricReferenceTester4<F1, F2, F3, F4, Distribution>(
      this, metric.getName(), Distribution.class,
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific counter.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4>
  MetricReferenceTester4<F1, F2, F3, F4, Long> referenceTo(
      Counter4<F1, F2, F3, F4> metric) {
    return referenceToImpl4(metric);
  }
  /**
   * Creates a reference to an five-dimensional metric.
   *
   * <p> <b>Important</b> When the metric's value type
   * {@code Integer}, use {@code Long} here. That's because the collection mechanism doesn't
   * distinguish between 32- and 64-bit integers, so the fact that the metric was an {@code
   * Integer} is long gone by the time this reference gets a hold of it.
   *
   * @param metricName the name of the metric.
   * @param valueType the value type of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   */
  public <F1, F2, F3, F4, F5, V>
  MetricReferenceTester5<F1, F2, F3, F4, F5, V> metricReference(
      String metricName,
      Class<V> valueType,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5) {
    return new MetricReferenceTester5<F1, F2, F3, F4, F5, V>(
        this, metricName, valueType,
        field1,
            field2,
            field3,
            field4,
            field5);
  }

  /**
   * Creates a reference to an five-dimensional event metric.
   *
   * @param metricName The name of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   */
  public <F1, F2, F3, F4, F5>
  MetricReferenceTester5<F1, F2, F3, F4, F5, Distribution> eventMetricReference(
      String metricName,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5) {
    return new MetricReferenceTester5<F1, F2, F3, F4, F5, Distribution>(
        this, metricName, Distribution.class,
        field1,
            field2,
            field3,
            field4,
            field5);
  }

  private <F1, F2, F3, F4, F5, V, M extends GenericMetric<V, M>>
  MetricReferenceTester5<F1, F2, F3, F4, F5, V> referenceToImpl5(
      GenericMetric<V, M> metric) {
    return new MetricReferenceTester5<F1, F2, F3, F4, F5, V>(
      this, metric.getName(), metric.getValueType(),
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, V>
  MetricReferenceTester5<F1, F2, F3, F4, F5, V> referenceTo(
      Metric5<F1, F2, F3, F4, F5, V> metric) {
    return referenceToImpl5(metric);
  }

  /**
   * Creates a metric tester for a specific event metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5>
  MetricReferenceTester5<F1, F2, F3, F4, F5, Distribution> referenceTo(
      EventMetric5<F1, F2, F3, F4, F5> metric) {
    // Can't use referenceToImpl because getUnderlyingMetric() is protected.
    return new MetricReferenceTester5<F1, F2, F3, F4, F5, Distribution>(
      this, metric.getName(), Distribution.class,
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific counter.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5>
  MetricReferenceTester5<F1, F2, F3, F4, F5, Long> referenceTo(
      Counter5<F1, F2, F3, F4, F5> metric) {
    return referenceToImpl5(metric);
  }
  /**
   * Creates a reference to an six-dimensional metric.
   *
   * <p> <b>Important</b> When the metric's value type
   * {@code Integer}, use {@code Long} here. That's because the collection mechanism doesn't
   * distinguish between 32- and 64-bit integers, so the fact that the metric was an {@code
   * Integer} is long gone by the time this reference gets a hold of it.
   *
   * @param metricName the name of the metric.
   * @param valueType the value type of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   */
  public <F1, F2, F3, F4, F5, F6, V>
  MetricReferenceTester6<F1, F2, F3, F4, F5, F6, V> metricReference(
      String metricName,
      Class<V> valueType,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6) {
    return new MetricReferenceTester6<F1, F2, F3, F4, F5, F6, V>(
        this, metricName, valueType,
        field1,
            field2,
            field3,
            field4,
            field5,
            field6);
  }

  /**
   * Creates a reference to an six-dimensional event metric.
   *
   * @param metricName The name of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   */
  public <F1, F2, F3, F4, F5, F6>
  MetricReferenceTester6<F1, F2, F3, F4, F5, F6, Distribution> eventMetricReference(
      String metricName,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6) {
    return new MetricReferenceTester6<F1, F2, F3, F4, F5, F6, Distribution>(
        this, metricName, Distribution.class,
        field1,
            field2,
            field3,
            field4,
            field5,
            field6);
  }

  private <F1, F2, F3, F4, F5, F6, V, M extends GenericMetric<V, M>>
  MetricReferenceTester6<F1, F2, F3, F4, F5, F6, V> referenceToImpl6(
      GenericMetric<V, M> metric) {
    return new MetricReferenceTester6<F1, F2, F3, F4, F5, F6, V>(
      this, metric.getName(), metric.getValueType(),
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, F6, V>
  MetricReferenceTester6<F1, F2, F3, F4, F5, F6, V> referenceTo(
      Metric6<F1, F2, F3, F4, F5, F6, V> metric) {
    return referenceToImpl6(metric);
  }

  /**
   * Creates a metric tester for a specific event metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, F6>
  MetricReferenceTester6<F1, F2, F3, F4, F5, F6, Distribution> referenceTo(
      EventMetric6<F1, F2, F3, F4, F5, F6> metric) {
    // Can't use referenceToImpl because getUnderlyingMetric() is protected.
    return new MetricReferenceTester6<F1, F2, F3, F4, F5, F6, Distribution>(
      this, metric.getName(), Distribution.class,
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific counter.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, F6>
  MetricReferenceTester6<F1, F2, F3, F4, F5, F6, Long> referenceTo(
      Counter6<F1, F2, F3, F4, F5, F6> metric) {
    return referenceToImpl6(metric);
  }
  /**
   * Creates a reference to an seven-dimensional metric.
   *
   * <p> <b>Important</b> When the metric's value type
   * {@code Integer}, use {@code Long} here. That's because the collection mechanism doesn't
   * distinguish between 32- and 64-bit integers, so the fact that the metric was an {@code
   * Integer} is long gone by the time this reference gets a hold of it.
   *
   * @param metricName the name of the metric.
   * @param valueType the value type of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   */
  public <F1, F2, F3, F4, F5, F6, F7, V>
  MetricReferenceTester7<F1, F2, F3, F4, F5, F6, F7, V> metricReference(
      String metricName,
      Class<V> valueType,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7) {
    return new MetricReferenceTester7<F1, F2, F3, F4, F5, F6, F7, V>(
        this, metricName, valueType,
        field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7);
  }

  /**
   * Creates a reference to an seven-dimensional event metric.
   *
   * @param metricName The name of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   */
  public <F1, F2, F3, F4, F5, F6, F7>
  MetricReferenceTester7<F1, F2, F3, F4, F5, F6, F7, Distribution> eventMetricReference(
      String metricName,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7) {
    return new MetricReferenceTester7<F1, F2, F3, F4, F5, F6, F7, Distribution>(
        this, metricName, Distribution.class,
        field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7);
  }

  private <F1, F2, F3, F4, F5, F6, F7, V, M extends GenericMetric<V, M>>
  MetricReferenceTester7<F1, F2, F3, F4, F5, F6, F7, V> referenceToImpl7(
      GenericMetric<V, M> metric) {
    return new MetricReferenceTester7<F1, F2, F3, F4, F5, F6, F7, V>(
      this, metric.getName(), metric.getValueType(),
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, F6, F7, V>
  MetricReferenceTester7<F1, F2, F3, F4, F5, F6, F7, V> referenceTo(
      Metric7<F1, F2, F3, F4, F5, F6, F7, V> metric) {
    return referenceToImpl7(metric);
  }

  /**
   * Creates a metric tester for a specific event metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, F6, F7>
  MetricReferenceTester7<F1, F2, F3, F4, F5, F6, F7, Distribution> referenceTo(
      EventMetric7<F1, F2, F3, F4, F5, F6, F7> metric) {
    // Can't use referenceToImpl because getUnderlyingMetric() is protected.
    return new MetricReferenceTester7<F1, F2, F3, F4, F5, F6, F7, Distribution>(
      this, metric.getName(), Distribution.class,
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific counter.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, F6, F7>
  MetricReferenceTester7<F1, F2, F3, F4, F5, F6, F7, Long> referenceTo(
      Counter7<F1, F2, F3, F4, F5, F6, F7> metric) {
    return referenceToImpl7(metric);
  }
  /**
   * Creates a reference to an eight-dimensional metric.
   *
   * <p> <b>Important</b> When the metric's value type
   * {@code Integer}, use {@code Long} here. That's because the collection mechanism doesn't
   * distinguish between 32- and 64-bit integers, so the fact that the metric was an {@code
   * Integer} is long gone by the time this reference gets a hold of it.
   *
   * @param metricName the name of the metric.
   * @param valueType the value type of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   */
  public <F1, F2, F3, F4, F5, F6, F7, F8, V>
  MetricReferenceTester8<F1, F2, F3, F4, F5, F6, F7, F8, V> metricReference(
      String metricName,
      Class<V> valueType,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8) {
    return new MetricReferenceTester8<F1, F2, F3, F4, F5, F6, F7, F8, V>(
        this, metricName, valueType,
        field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8);
  }

  /**
   * Creates a reference to an eight-dimensional event metric.
   *
   * @param metricName The name of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   */
  public <F1, F2, F3, F4, F5, F6, F7, F8>
  MetricReferenceTester8<F1, F2, F3, F4, F5, F6, F7, F8, Distribution> eventMetricReference(
      String metricName,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8) {
    return new MetricReferenceTester8<F1, F2, F3, F4, F5, F6, F7, F8, Distribution>(
        this, metricName, Distribution.class,
        field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8);
  }

  private <F1, F2, F3, F4, F5, F6, F7, F8, V, M extends GenericMetric<V, M>>
  MetricReferenceTester8<F1, F2, F3, F4, F5, F6, F7, F8, V> referenceToImpl8(
      GenericMetric<V, M> metric) {
    return new MetricReferenceTester8<F1, F2, F3, F4, F5, F6, F7, F8, V>(
      this, metric.getName(), metric.getValueType(),
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, F6, F7, F8, V>
  MetricReferenceTester8<F1, F2, F3, F4, F5, F6, F7, F8, V> referenceTo(
      Metric8<F1, F2, F3, F4, F5, F6, F7, F8, V> metric) {
    return referenceToImpl8(metric);
  }

  /**
   * Creates a metric tester for a specific event metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, F6, F7, F8>
  MetricReferenceTester8<F1, F2, F3, F4, F5, F6, F7, F8, Distribution> referenceTo(
      EventMetric8<F1, F2, F3, F4, F5, F6, F7, F8> metric) {
    // Can't use referenceToImpl because getUnderlyingMetric() is protected.
    return new MetricReferenceTester8<F1, F2, F3, F4, F5, F6, F7, F8, Distribution>(
      this, metric.getName(), Distribution.class,
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific counter.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, F6, F7, F8>
  MetricReferenceTester8<F1, F2, F3, F4, F5, F6, F7, F8, Long> referenceTo(
      Counter8<F1, F2, F3, F4, F5, F6, F7, F8> metric) {
    return referenceToImpl8(metric);
  }
  /**
   * Creates a reference to an nine-dimensional metric.
   *
   * <p> <b>Important</b> When the metric's value type
   * {@code Integer}, use {@code Long} here. That's because the collection mechanism doesn't
   * distinguish between 32- and 64-bit integers, so the fact that the metric was an {@code
   * Integer} is long gone by the time this reference gets a hold of it.
   *
   * @param metricName the name of the metric.
   * @param valueType the value type of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   */
  public <F1, F2, F3, F4, F5, F6, F7, F8, F9, V>
  MetricReferenceTester9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V> metricReference(
      String metricName,
      Class<V> valueType,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9) {
    return new MetricReferenceTester9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V>(
        this, metricName, valueType,
        field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9);
  }

  /**
   * Creates a reference to an nine-dimensional event metric.
   *
   * @param metricName The name of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   */
  public <F1, F2, F3, F4, F5, F6, F7, F8, F9>
  MetricReferenceTester9<F1, F2, F3, F4, F5, F6, F7, F8, F9, Distribution> eventMetricReference(
      String metricName,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9) {
    return new MetricReferenceTester9<F1, F2, F3, F4, F5, F6, F7, F8, F9, Distribution>(
        this, metricName, Distribution.class,
        field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9);
  }

  private <F1, F2, F3, F4, F5, F6, F7, F8, F9, V, M extends GenericMetric<V, M>>
  MetricReferenceTester9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V> referenceToImpl9(
      GenericMetric<V, M> metric) {
    return new MetricReferenceTester9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V>(
      this, metric.getName(), metric.getValueType(),
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, F6, F7, F8, F9, V>
  MetricReferenceTester9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V> referenceTo(
      Metric9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V> metric) {
    return referenceToImpl9(metric);
  }

  /**
   * Creates a metric tester for a specific event metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, F6, F7, F8, F9>
  MetricReferenceTester9<F1, F2, F3, F4, F5, F6, F7, F8, F9, Distribution> referenceTo(
      EventMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9> metric) {
    // Can't use referenceToImpl because getUnderlyingMetric() is protected.
    return new MetricReferenceTester9<F1, F2, F3, F4, F5, F6, F7, F8, F9, Distribution>(
      this, metric.getName(), Distribution.class,
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific counter.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, F6, F7, F8, F9>
  MetricReferenceTester9<F1, F2, F3, F4, F5, F6, F7, F8, F9, Long> referenceTo(
      Counter9<F1, F2, F3, F4, F5, F6, F7, F8, F9> metric) {
    return referenceToImpl9(metric);
  }
  /**
   * Creates a reference to an ten-dimensional metric.
   *
   * <p> <b>Important</b> When the metric's value type
   * {@code Integer}, use {@code Long} here. That's because the collection mechanism doesn't
   * distinguish between 32- and 64-bit integers, so the fact that the metric was an {@code
   * Integer} is long gone by the time this reference gets a hold of it.
   *
   * @param metricName the name of the metric.
   * @param valueType the value type of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @param field10 The tenth field
   */
  public <F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V>
  MetricReferenceTester10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V> metricReference(
      String metricName,
      Class<V> valueType,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9,
      Field<F10> field10) {
    return new MetricReferenceTester10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V>(
        this, metricName, valueType,
        field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9,
            field10);
  }

  /**
   * Creates a reference to an ten-dimensional event metric.
   *
   * @param metricName The name of the metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @param field10 The tenth field
   */
  public <F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>
  MetricReferenceTester10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, Distribution> eventMetricReference(
      String metricName,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9,
      Field<F10> field10) {
    return new MetricReferenceTester10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, Distribution>(
        this, metricName, Distribution.class,
        field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9,
            field10);
  }

  private <F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V, M extends GenericMetric<V, M>>
  MetricReferenceTester10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V> referenceToImpl10(
      GenericMetric<V, M> metric) {
    return new MetricReferenceTester10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V>(
      this, metric.getName(), metric.getValueType(),
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V>
  MetricReferenceTester10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V> referenceTo(
      Metric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V> metric) {
    return referenceToImpl10(metric);
  }

  /**
   * Creates a metric tester for a specific event metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>
  MetricReferenceTester10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, Distribution> referenceTo(
      EventMetric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> metric) {
    // Can't use referenceToImpl because getUnderlyingMetric() is protected.
    return new MetricReferenceTester10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, Distribution>(
      this, metric.getName(), Distribution.class,
      Iterables.toArray(metric.getFieldNames(), String.class));
  }

  /**
   * Creates a metric tester for a specific counter.
   *
   * @param metric the metric to create a tester for.
   */
  public <F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>
  MetricReferenceTester10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, Long> referenceTo(
      Counter10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> metric) {
    return referenceToImpl10(metric);
  }
}