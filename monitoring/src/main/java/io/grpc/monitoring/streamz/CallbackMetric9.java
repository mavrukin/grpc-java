// Generated by generate.py

package io.grpc.monitoring.streamz;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;

import javax.annotation.Generated;

/**
 * A nine-dimensional CallbackMetric.
 *
 * <p>This class may only be instantiated through a {@link MetricFactory}.
 *
 * @param <F1> The type of the first metric field.
 * @param <F2> The type of the second metric field.
 * @param <F3> The type of the third metric field.
 * @param <F4> The type of the fourth metric field.
 * @param <F5> The type of the fifth metric field.
 * @param <F6> The type of the sixth metric field.
 * @param <F7> The type of the seventh metric field.
 * @param <F8> The type of the eighth metric field.
 * @param <F9> The type of the ninth metric field.
 * @param <V> The type of the values stored in metric cells.
 * @author nsakharo@google.com (Nick Sakharov)
 */
@Generated(value = "generate.py")
public class CallbackMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V>
    extends CallbackMetric<V, CallbackMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V>> {

  CallbackMetric9(String name, ValueTypeTraits<V> traits, Metadata metadata,
      ImmutableList<? extends Field<?>> fields) {
    super(name, traits, metadata, fields);
    Preconditions.checkArgument(getNumFields() == 9);
  }

  /**
   * Sets the value of the given cell to {@code value}. Must be called only from the
   * {@link CallbackTrigger} instance associated with the metric - any calls outside of
   * the trigger context will be ignored (and will result in exception if strict checking
   * is enabled). Also, each cell should be set at most once - while subsequent set()
   * invocations for the same cell will succeed, they too will result in exception if strict
   * checking is enabled.
   *
   * <p>Also see {@link StoredCell#updateValue(Object)} for restrictions placed on the
   * {@code value}.
   *
   * @see StoredCell#updateValue(Object)
   */
  public void set(
      Metric9.CellKey<F1, F2, F3, F4, F5, F6, F7, F8, F9> key,
      V value) {
    super.set(key, value);
  }

  /**
   * @see #set(Metric9.CellKey<F1, F2, F3, F4, F5, F6, F7, F8, F9>, V)
   */
  public void set(
      F1 field1,
      F2 field2,
      F3 field3,
      F4 field4,
      F5 field5,
      F6 field6,
      F7 field7,
      F8 field8,
      F9 field9,
      V value) {
    // TODO(nsakharo): Move createCellKey() out of Metric classes.
    set(
        Metric9.createCellKey(
            field1, field2, field3, field4, field5, field6, field7, field8, field9),
        value);
  }

  /**
   * Sets the value of the given cell to {@code value}, while setting the timestamp to
   * {@code timestampMicros}.
   *
   * Must be called only from the {@link CallbackTrigger} instance associated with the
   * metric - any calls outside of the trigger context will be ignored (and will result in
   * an exception if strict checking is enabled). Also, each cell should be set at most
   * once - while subsequent set() invocations for the same cell will succeed, they too
   * will result in an exception if strict checking is enabled.
   *
   * Setting timestamp explicitly is an advanced feature: use {@code #set(V)} instead
   * unless it really is necessary to do so. If timestamp is set explicitly, then ensure
   * that it is after the time when the corresponding metric was created: monitoring systems are
   * likely to discard data if timestamps are out of order.
   *
   * <p>Also see {@link StoredCell#updateValue(Object)} for restrictions placed on the
   * {@code value}.
   *
   * @see StoredCell#updateValue(Object)
   */
  public void set(
      Metric9.CellKey<F1, F2, F3, F4, F5, F6, F7, F8, F9> key,
      V value,
      long timestampMicros) {
    super.set(key, value, timestampMicros);
  }

  /**
   * @see #set(Metric9.CellKey<F1, F2, F3, F4, F5, F6, F7, F8, F9>, V, long)
   */
  public void set(
      F1 field1,
      F2 field2,
      F3 field3,
      F4 field4,
      F5 field5,
      F6 field6,
      F7 field7,
      F8 field8,
      F9 field9,
      V value,
      long timestampMicros) {
    set(
        Metric9.createCellKey(
            field1, field2, field3, field4, field5, field6, field7, field8, field9),
        value,
        timestampMicros);
  }

  /**
   * Sets the value of the given cell to {@code value}, while setting the timestamp and
   * reset timestamp to {@code timestampMicros} and {@code resetTimestampMicros}, respectively.
   *
   * Must be called only from the {@link CallbackTrigger} instance associated with the
   * metric - any calls outside of the trigger context will be ignored (and will result in
   * an exception if strict checking is enabled). Also, each cell should be set at most
   * once - while subsequent set() invocations for the same cell will succeed, they too
   * will result in an exception if strict checking is enabled.
   *
   * Setting timestamps explicitly is an advanced feature: use {@code #set(V)} instead
   * unless it really is necessary to do so. If timestamps are set explicitly, then ensure
   * that timestamps and reset timestamps do not go backwards: monitoring systems are
   * likely to discard data if timestamps are out of order. It is an error for the reset
   * timestamp to be higher than the timestamp.
   *
   * <p>Also see {@link StoredCell#updateValue(Object)} for restrictions placed on the
   * {@code value}.
   *
   * @see StoredCell#updateValue(Object)
   */
  public void set(
      Metric9.CellKey<F1, F2, F3, F4, F5, F6, F7, F8, F9> key,
      V value,
      long timestampMicros, long resetTimestampMicros) {
    super.set(key, value, timestampMicros, resetTimestampMicros);
  }

  /**
   * @see #set(Metric9.CellKey<F1, F2, F3, F4, F5, F6, F7, F8, F9>, V, long, long)
   */
  public void set(
      F1 field1,
      F2 field2,
      F3 field3,
      F4 field4,
      F5 field5,
      F6 field6,
      F7 field7,
      F8 field8,
      F9 field9,
      V value,
      long timestampMicros, long resetTimestampMicros) {
    set(
        Metric9.createCellKey(
            field1, field2, field3, field4, field5, field6, field7, field8, field9),
        value,
        timestampMicros, resetTimestampMicros);
  }
}