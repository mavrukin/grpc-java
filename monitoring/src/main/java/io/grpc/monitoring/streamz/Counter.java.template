// Generated by ${generator}

package io.grpc.monitoring.streamz;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;

import java.util.Set;

import javax.annotation.Generated;

/**
 * A ${number}-dimensional Counter. This is essentially a
 * Metric${dimensionality}<${types}, Long>,
 * with restricted API that only permits incrementing the metric.
 *
 * <p>This class may only be instantiated through a {@link MetricFactory}.
 *
${type_javadoc} * @author konigsberg@google.com (Robert Konigsberg)
 */
@Generated(value = "${generator}")
public class Counter${dimensionality}<${types}>
    extends StoredMetric<Long, Counter${dimensionality}<${types}>> {

  Counter${dimensionality}(String name, ValueTypeTraits<Long> traits, Metadata metadata,
      ImmutableList<? extends Field<?>> fields) {
    super(name, traits, metadata, fields);
    Preconditions.checkArgument(getNumFields() == ${dimensionality});
  }

  /**
   * @see StoredCell#increment()
   */
  public void increment(
      Metric${dimensionality}.CellKey<${types}> key) {
    super.increment(key);
  }

  /**
   * @see #increment(Metric${dimensionality}.CellKey<${types}>)
   */
  public void increment(
      ${params}) {
    increment(Metric${dimensionality}.createCellKey(
        ${values}));
  }

  /**
   * @see StoredCell#incrementBy(Number)
   */
  public void incrementBy(
      Metric${dimensionality}.CellKey<${types}> key,
      long value) {
    super.incrementBy(key, value);
  }

  /**
   * @see #increment(Metric${dimensionality}.CellKey<${types}>, long)
   */
  public void incrementBy(
      ${params},
      long value) {
    incrementBy(
        Metric${dimensionality}.createCellKey(
            ${values}),
        value);
  }

  /**
   * @see StoredMetric#clear(FieldTuple)
   */
  public void clear(
      Metric${dimensionality}.CellKey<${types}> key) {
    super.clear(key);
  }

  /**
   * @see #clear(Metric${dimensionality}.CellKey<${types}>)
   */
  public void clear(
      ${params}) {
    clear(Metric${dimensionality}.createCellKey(
        ${values}));
  }

  /**
   * @see StoredCell#getValue()
   */
  public Long get(
      Metric${dimensionality}.CellKey<${types}> key) {
    return super.get(key);
  }

  /**
   * @see #get(Metric${dimensionality}.CellKey<${types}>)
   */
  public Long get(
      ${params}) {
    return get(Metric${dimensionality}.createCellKey(
        ${values}));
  }

  /**
   * @see StoredMetric#keySet()
   */
  // We ensure that only FieldTuples created by createCellKey are used as keys in the map
  @SuppressWarnings("unchecked")
  @Override
  public Set<Metric${dimensionality}.CellKey<${types}>> keySet() {
    return (Set<Metric${dimensionality}.CellKey<${types}>>) super.keySet();
  }
}