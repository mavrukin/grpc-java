// Copyright 2010 Google Inc. All Rights Reserved.
// Generated by %(generator)s

package io.grpc.monitoring.streamz;

import com.google.common.base.Randoms;
import com.google.common.base.Supplier;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.inject.ProvidedBy;

import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

import javax.annotation.Generated;

/**
 * Factory for Streamz metrics.  To obtain the {@code MetricFactory} that
 * is used by Streamz to create metrics for export, use
 * {@link #getDefault()}.  For tests, see
 * {@link io.grpc.monitoring.streamz.TestMetricFactory}.
 *
 * <p>Examples:
 *
 * <pre>
 * // A temperature gauge: a Metric comprising a single stream of doubles.
 * private static final Metric0&lt;Double> temp = MetricFactory.getDefault().newMetric(
 *     "/hw/temperature", Double.class, new Metadata("The temperature in Kelvin"));
 *
 * temp.set(273.16); // brrr!
 * temp.set(373.16); // phew!
 *
 * // Counters of cache accesses: a metric of two integer streams, by a
 * // boolean, hit/miss.
 * Metric1&lt;Boolean, Integer> cacheCounters = metricFactory.newMetric(
 *     "/myservice/counters", Integer.class,
 *     new Metadata("Counters of cache accesses, keyed by hit/miss").setCumulative(),
 *     Field.ofBoolean("hit"));
 *
 * // Record a cache access:
 * boolean hit = cache.put(field, value) == null;
 * cacheCounters.increment(hit);
 *
 * // Reset both buckets:
 * cacheCounters.set(false, 0); // misses
 * cacheCounters.set(true, 0);  // hits
 * </pre>
 *
 * <p>Event metrics are a bridge between streams of events and time-series
 * monitoring.  EventMetric exports various aggregations about some
 * quantitative aspect (or "metric") of an event.  For example, the event might
 * be a network request and the metric might be its request latency in
 * milliseconds or its packet size in bytes.
 *
 * <p>EventMetric computes statistics such as the sample count, mean, total,
 * minimum, maximum and variance, and a histogram (with a customizable
 * bucketing function), and exports them to humans via the /streamz HTTP
 * servlet, and to monitoring tools via the Streamz RPC service.
 *
 * <p>Example usage:
 *
 * <pre>
 *   EventMetric0 requestBytes = metricFactory.newEventMetric(
 *       "/myservice/request_bytes", new Metadata("request size in bytes")));
 *
 *   // Provide sample data:
 *   requestBytes.record(16512);
 *   ...
 *   requestBytes.record(4096);
 *
 *   EventMetric1<Integer> latencyByResponseCode = metricFactory.newEventMetric(
 *       "/myservice/response_latency",
 *       new Metadata("response latency in ms"),
 *       Field.ofInteger("response_code"));
 *
 *   // Record statistics about a request:
 *   latencyByResponseCode.record(
 *       response.getStatusCode(),
 *       stopWatch.stop().elapsedMillis());
 * </pre>
 *
 * @author flooey@google.com (Adam Vartanian)
 */
@Generated(value = "%(generator)s")
@ProvidedBy(DefaultMetricFactoryProvider.class)
public abstract class MetricFactory {

  /**
   * Metric factory that registers all created metrics with the Streamz root.
   *
   * @author flooey@google.com (Adam Vartanian)
   */
  static class RootMetricFactory extends MetricFactory {

    private final Root root;

    RootMetricFactory(Root root) {
      this.root = root;
    }

    @Override
    void onCreate(GenericMetric<?, ?> metric) {
      root.add(metric);
    }

    @Override
    void applyToMetric(String name, Receiver<GenericMetric<Object, ?>> callback) {
      root.applyToMetric(name, callback);
    }

    @Override
    void applyToMetricsBeneath(String pattern, Receiver<GenericMetric<Object, ?>> callback) {
      root.applyToMetricsBeneath(pattern, callback);
    }

    @Override
    void applyToMetrics(Iterable<String> names, Receiver<GenericMetric<Object, ?>> callback) {
      root.applyToMetrics(names, callback);
    }

    @Override
    void applyToMetricMetadata(Receiver<GenericMetric<Object, ?>> callback) {
      root.applyToMetricMetadata(callback);
    }
  }

  /**
   * A globally unique identifier for the metric factory.
   */
  private final long id = Randoms.secureRandom().nextLong();

  /**
   * Incremented whenever there is a change in the set of metrics.
   */
  private AtomicInteger generation = new AtomicInteger();

  /**
   * Returns the default (production) metric factory.  For tests, see
   * {@link io.grpc.monitoring.streamz.TestMetricFactory}.
   */
  public static MetricFactory getDefault() {
    return Root.getDefault().getMetricFactory();
  }

  private void internalOnCreate(GenericMetric<?, ?> metric) {
    generation.incrementAndGet();
    onCreate(metric);
    Streamz.initialize();
  }

  /**
   * Called after a metric is created from this factory.  Subclasses should
   * override this method to respond to metrics being created.
   */
  abstract void onCreate(GenericMetric<?, ?> metric);

  /**
   * Applies the specified Receiver to the named metric, while holding the
   * namespace lock.  If the metric doesn't exist, a no-op.  {@code callback}
   * should not retain a reference to its argument once it completes.
   */
  abstract void applyToMetric(String name, Receiver<GenericMetric<Object, ?>> callback);

  /**
   * Applies the specified Receiver, while holding the namespace lock,
   * to all metrics whose names are "beneath" {@code directory},
   * according to the usual UNIX convention. {@code directory} must
   * have a trailing "/". {@code callback} should not retain a
   * reference to its argument once it completes.
   */
  abstract void applyToMetricsBeneath(String pattern, Receiver<GenericMetric<Object, ?>> callback);

  /**
   * Applies the specified Receiver, while holding the namespace lock, to all
   * metrics matching provided list of names. Names ending with trailing "/" (slash),
   * per usual UNIX conventions, will be considered to be {@code directory} names and
   * will rely on prefix matching instead.
   *
   * <p>{@code callback} should not retain a reference to its argument once it
   * completes.
   */
  abstract void applyToMetrics(Iterable<String> pattern,
      Receiver<GenericMetric<Object, ?>> callback);

  /**
   * For the purpose of reading only metric metadata, applies the specified Receiver to
   * all metrics while holding the namespace lock. No triggers are invoked before applying
   * the Receiver, and {@link GenericMetric#applyToEachCell} must not be called within
   * {@code callback}.
   *
   * <p>
   * {@code callback} should not retain a reference to its argument once it completes.
   */
  abstract void applyToMetricMetadata(Receiver<GenericMetric<Object, ?>> callback);

  /**
   * Returns the globally unique ID for the metric factory.
   */
  final long getId() { return id; }

  /**
   * Returns the generation, which is incremented whenever there is a change in the set of metrics.
   */
  final int getGeneration() { return generation.get(); }

  /**
   * Constructs a zero-dimensional Metric whose values may be of any type,
   * including Protocol Messages.
   *
   * <p>Note, for a Protocol Message to be used as the value type of a Metric,
   * it must have the MessageSet extension, for example:
   *
   * <pre>
   * import "net/proto2/bridge/proto/message_set.proto";
   * message Foo {
   *   extend proto2.bridge.MessageSet {
   *     optional Foo message_set_extension = 314159; // unique identifier
   *   }
   *   // ... rest of message ...
   * }
   * </pre>
   *
   * Constructs a zero-dimensional metric.
   * @param name the name of this metric.  Must conform to this extended
   *   regexp: (/[a-zA-Z0-9_-]+)+.  It should follow Streamz conventions: http://go/streamz-naming.
   * @param valueClass Must match &lt;V>. V must be one of
   *     Boolean, Float, Double, Integer, Long, String, Enum
   *     or a subtype of {@link com.google.protobuf.Message}.
   *     For {@link Distribution}, use {@link #newEventMetric(String, Metadata)}.
   * @param metadata The metric's Metadata: description and annotations.
   * @return The metric
   */
  public final <V> Metric0<V> newMetric(
      String name, Class<V> valueClass, Metadata metadata) {
    Metric0<V> metric = new Metric0<V>(name, ValueTypeTraits.getTraits(valueClass), metadata);
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a legacy one-dimensional Void-valued metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *     It should follow Streamz conventions: http://go/streamz-naming.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @return The metric
   */
  final <F1> Metric1<F1, Void> newLegacyVoidMetric(
      String name, Metadata metadata,
      Field<F1> field1) {
    Metric1<F1, Void> metric =
        new Metric1<F1, Void>(
            name, ValueTypeTraits.getLegacyVoidTrait(), metadata,
            ImmutableList.of(field1));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a zero-dimensional CallbackMetric.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *     It should follow Streamz conventions: http://go/streamz-naming.
   * @param valueClass see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @return The metric
   */
  public final <V> CallbackMetric0<V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata) {
    CallbackMetric0<V> metric =
        new CallbackMetric0<V>(name, ValueTypeTraits.getTraits(valueClass), metadata);
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a zero-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *     It should follow Streamz conventions: http://go/streamz-naming.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @return The metric
   */
  public final Counter0 newCounter(String name, Metadata metadata) {
    Counter0 metric = new Counter0(
        name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative());
    internalOnCreate(metric);

    /* Special case for zero-dimensional counters. */
    metric.incrementBy(0);
    return metric;
  }

  /**
   * Constructs an zero-dimensional EventMetric.
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *     It should follow Streamz conventions: http://go/streamz-naming.
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @return The metric
   */
  public final EventMetric0 newEventMetric(String name, Bucketer bucketer, Metadata metadata) {
    EventMetric0 metric = new EventMetric0(name, bucketer, metadata);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs an zero-dimensional EventMetric with default bucketer.
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *     It should follow Streamz conventions: http://go/streamz-naming.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @return The metric
   */
  public final EventMetric0 newEventMetric(String name, Metadata metadata) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata);
  }

  /**
   * Constructs a zero-dimensional VirtualMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *     It should follow Streamz conventions: http://go/streamz-naming.
   * @param valueClass Must match &lt;V>. see {@link #newMetric(String, Class, Metadata)}.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param supplier callback to supply the cell value.
   * @return The metric
   * @deprecated Use a CallbackMetric instead.
   */
  @Deprecated
  public final <V> VirtualMetric0<V> newMetric(
      String name, Class<V> valueClass, Metadata metadata, Supplier<V> supplier) {
    VirtualMetric0<V> metric = new VirtualMetric0<V>(
        name, ValueTypeTraits.getTraits(valueClass), metadata, supplier);
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Convenience constructor for simple Metrics (with no fields) whose value
   * never changes.  Such metrics are annotated CONSTANT.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *     It should follow Streamz conventions: http://go/streamz-naming.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. Will
   *     have setConstant() called on it before construction.
   * @param constantValue the Metric's sole value.
   *     Must be of class V, not a subclass.
   * @return The metric
   */
  public final <V> ConstantMetric<V> newConstant(
      String name, V constantValue, Metadata metadata) {
    // This is safe if the user obeys the 'Must be of class V, not a subclass.'
    // precondition.
    @SuppressWarnings("unchecked")
    Class<V> valueClass = (Class<V>) constantValue.getClass();
    ConstantMetric<V> metric = new ConstantMetric<V>(name, valueClass, constantValue,
        metadata.setConstant());
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a new {@link CallbackTrigger} instance, used to update one or more
   * {@link CallbackMetric} instances. The {@code CallbackTrigger} will be invoked
   * whenever the system needs to obtain the associated {@code CallbackMetric} values.
   * A single {@code CallbackTrigger} could be associated with multiple {@code CallbackMetric}
   * instances and vice versa - each {@code CallbackMetric} could be updated by multiple
   * triggers. For example,
   *
   * <pre>
   * final CallbackMetric0<Long> metric1 =
   *    factory.newCallbackMetric("/metric1", Long.class, metadata);
   * final CallbackMetric1<Long, String> metric2 =
   *     factory.newCallbackMetric("/metric2", Long.class, metadata);
   *
   * CallbackTrigger trigger = factory.newTrigger(metric1, metric2,
   *     new Runnable() {
   *       @Override public void run() {
   *         metric1.set(System.something());
   *         metric2.set("x", System.somethingElse());
   *       }
   *     });
   * </pre>
   *
   * @see CallbackTrigger for more information.
   *
   * @param trigger a Runnable that will be executed once per evaluation of all metrics
   *     associated with the CallbackTrigger instance. These metrics will accept new
   *     values only when invoked inside provided Runnable instance.
   * @return the new callback trigger instance
   */
  public final CallbackTrigger newTrigger(Set<? extends CallbackMetric<?, ?>> metrics,
      Runnable trigger) {
    // FIXME(nsakharo): Validate that all metrics belong to the same registry. Could be done
    // by adding onCreate(CallbackTrigger) method or by exposing MetricRegistry.getMetrics() all
    // the way to MetricFactory.
    CallbackTrigger callbackTrigger = new CallbackTrigger(trigger, metrics);
    callbackTrigger.register();
    return callbackTrigger;
  }

  /**
   * Creates a new {@link CallbackTrigger} instance associated with given metrics, providing
   * shortcut form for {@code MetricFactory.newTrigger(ImmutableSet.of(metric1, ...), trigger);}.
   *
   * See {@link MetricFactory#newTrigger(java.util.Set, java.lang.Runnable)} for more details.
   */
  public final CallbackTrigger newTrigger(CallbackMetric<?, ?> metric1,
      Runnable trigger) {
    return newTrigger(ImmutableSet.of(metric1), trigger);
  }

  /**
   * Creates a new {@link CallbackTrigger} instance associated with given metrics, providing
   * shortcut form for {@code MetricFactory.newTrigger(ImmutableSet.of(metric1, ...), trigger);}.
   *
   * See {@link MetricFactory#newTrigger(java.util.Set, java.lang.Runnable)} for more details.
   */
  public final CallbackTrigger newTrigger(CallbackMetric<?, ?> metric1,
      CallbackMetric<?, ?> metric2,
      Runnable trigger) {
    return newTrigger(ImmutableSet.of(metric1, metric2), trigger);
  }

  /**
   * Creates a new {@link CallbackTrigger} instance associated with given metrics, providing
   * shortcut form for {@code MetricFactory.newTrigger(ImmutableSet.of(metric1, ...), trigger);}.
   *
   * See {@link MetricFactory#newTrigger(java.util.Set, java.lang.Runnable)} for more details.
   */
  public final CallbackTrigger newTrigger(CallbackMetric<?, ?> metric1,
      CallbackMetric<?, ?> metric2,
      CallbackMetric<?, ?> metric3,
      Runnable trigger) {
    return newTrigger(ImmutableSet.of(metric1, metric2, metric3), trigger);
  }

  /**
   * Creates a new {@link CallbackTrigger} instance associated with given metrics, providing
   * shortcut form for {@code MetricFactory.newTrigger(ImmutableSet.of(metric1, ...), trigger);}.
   *
   * See {@link MetricFactory#newTrigger(java.util.Set, java.lang.Runnable)} for more details.
   */
  public final CallbackTrigger newTrigger(CallbackMetric<?, ?> metric1,
      CallbackMetric<?, ?> metric2,
      CallbackMetric<?, ?> metric3,
      CallbackMetric<?, ?> metric4,
      Runnable trigger) {
    return newTrigger(ImmutableSet.of(metric1, metric2, metric3, metric4), trigger);
  }

  /**
   * Creates a new {@link CallbackTrigger} instance associated with given metrics, providing
   * shortcut form for {@code MetricFactory.newTrigger(ImmutableSet.of(metric1, ...), trigger);}.
   *
   * See {@link MetricFactory#newTrigger(java.util.Set, java.lang.Runnable)} for more details.
   */
  public final CallbackTrigger newTrigger(CallbackMetric<?, ?> metric1,
      CallbackMetric<?, ?> metric2,
      CallbackMetric<?, ?> metric3,
      CallbackMetric<?, ?> metric4,
      CallbackMetric<?, ?> metric5,
      Runnable trigger) {
    return newTrigger(ImmutableSet.of(metric1, metric2, metric3, metric4, metric5), trigger);
  }
%(factory_methods_MetricFactory)s
}