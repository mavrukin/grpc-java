// Generated by ${generator}

package io.grpc.monitoring.streamz;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;

import javax.annotation.Generated;

/**
 * A ${number}-dimensional CallbackMetric.
 *
 * <p>This class may only be instantiated through a {@link MetricFactory}.
 *
${type_javadoc} * @param <V> The type of the values stored in metric cells.
 * @author nsakharo@google.com (Nick Sakharov)
 */
@Generated(value = "${generator}")
public class CallbackMetric${dimensionality}<${types}, V>
    extends CallbackMetric<V, CallbackMetric${dimensionality}<${types}, V>> {

  CallbackMetric${dimensionality}(String name, ValueTypeTraits<V> traits, Metadata metadata,
      ImmutableList<? extends Field<?>> fields) {
    super(name, traits, metadata, fields);
    Preconditions.checkArgument(getNumFields() == ${dimensionality});
  }

  /**
   * Sets the value of the given cell to {@code value}. Must be called only from the
   * {@link CallbackTrigger} instance associated with the metric - any calls outside of
   * the trigger context will be ignored (and will result in exception if strict checking
   * is enabled). Also, each cell should be set at most once - while subsequent set()
   * invocations for the same cell will succeed, they too will result in exception if strict
   * checking is enabled.
   *
   * <p>Also see {@link StoredCell#updateValue(Object)} for restrictions placed on the
   * {@code value}.
   *
   * @see StoredCell#updateValue(Object)
   */
  public void set(
      Metric${dimensionality}.CellKey<${types}> key,
      V value) {
    super.set(key, value);
  }

  /**
   * @see #set(Metric${dimensionality}.CellKey<${types}>, V)
   */
  public void set(
      ${params},
      V value) {
    // TODO(nsakharo): Move createCellKey() out of Metric classes.
    set(
        Metric${dimensionality}.createCellKey(
            ${values}),
        value);
  }

  /**
   * Sets the value of the given cell to {@code value}, while setting the timestamp to
   * {@code timestampMicros}.
   *
   * Must be called only from the {@link CallbackTrigger} instance associated with the
   * metric - any calls outside of the trigger context will be ignored (and will result in
   * an exception if strict checking is enabled). Also, each cell should be set at most
   * once - while subsequent set() invocations for the same cell will succeed, they too
   * will result in an exception if strict checking is enabled.
   *
   * Setting timestamp explicitly is an advanced feature: use {@code #set(V)} instead
   * unless it really is necessary to do so. If timestamp is set explicitly, then ensure
   * that it is after the time when the corresponding metric was created: monitoring systems are
   * likely to discard data if timestamps are out of order.
   *
   * <p>Also see {@link StoredCell#updateValue(Object)} for restrictions placed on the
   * {@code value}.
   *
   * @see StoredCell#updateValue(Object)
   */
  public void set(
      Metric${dimensionality}.CellKey<${types}> key,
      V value,
      long timestampMicros) {
    super.set(key, value, timestampMicros);
  }

  /**
   * @see #set(Metric${dimensionality}.CellKey<${types}>, V, long)
   */
  public void set(
      ${params},
      V value,
      long timestampMicros) {
    set(
        Metric${dimensionality}.createCellKey(
            ${values}),
        value,
        timestampMicros);
  }

  /**
   * Sets the value of the given cell to {@code value}, while setting the timestamp and
   * reset timestamp to {@code timestampMicros} and {@code resetTimestampMicros}, respectively.
   *
   * Must be called only from the {@link CallbackTrigger} instance associated with the
   * metric - any calls outside of the trigger context will be ignored (and will result in
   * an exception if strict checking is enabled). Also, each cell should be set at most
   * once - while subsequent set() invocations for the same cell will succeed, they too
   * will result in an exception if strict checking is enabled.
   *
   * Setting timestamps explicitly is an advanced feature: use {@code #set(V)} instead
   * unless it really is necessary to do so. If timestamps are set explicitly, then ensure
   * that timestamps and reset timestamps do not go backwards: monitoring systems are
   * likely to discard data if timestamps are out of order. It is an error for the reset
   * timestamp to be higher than the timestamp.
   *
   * <p>Also see {@link StoredCell#updateValue(Object)} for restrictions placed on the
   * {@code value}.
   *
   * @see StoredCell#updateValue(Object)
   */
  public void set(
      Metric${dimensionality}.CellKey<${types}> key,
      V value,
      long timestampMicros, long resetTimestampMicros) {
    super.set(key, value, timestampMicros, resetTimestampMicros);
  }

  /**
   * @see #set(Metric${dimensionality}.CellKey<${types}>, V, long, long)
   */
  public void set(
      ${params},
      V value,
      long timestampMicros, long resetTimestampMicros) {
    set(
        Metric${dimensionality}.createCellKey(
            ${values}),
        value,
        timestampMicros, resetTimestampMicros);
  }
}