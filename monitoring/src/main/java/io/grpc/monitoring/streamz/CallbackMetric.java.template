// Generated by %(generator)s

package io.grpc.monitoring.streamz;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;

import javax.annotation.Generated;

/**
 * A %(number)s-dimensional CallbackMetric.
 *
 * <p>This class may only be instantiated through a {@link MetricFactory}.
 *
%(type_javadoc)s * @param <V> The type of the values stored in metric cells.
 * @author nsakharo@google.com (Nick Sakharov)
 */
@Generated(value = "%(generator)s")
public class CallbackMetric%(dimensionality)d<%(types)s, V>
    extends CallbackMetric<V, CallbackMetric%(dimensionality)d<%(types)s, V>> {

  CallbackMetric%(dimensionality)d(String name, ValueTypeTraits<V> traits, Metadata metadata,
      ImmutableList<? extends Field<?>> fields) {
    super(name, traits, metadata, fields);
    Preconditions.checkArgument(getNumFields() == %(dimensionality)d);
  }

  /**
   * Sets the value of the given cell to {@code value}. Must be called only from the
   * {@link CallbackTrigger} instance associated with the metric - any calls outside of
   * the trigger context will be ignored (and will result in exception if strict checking
   * is enabled). Also, each cell should be set at most once - while subsequent set()
   * invocations for the same cell will succeed, they too will result in exception if strict
   * checking is enabled.
   *
   * <p>Also see {@link StoredCell#updateValue(Object)} for restrictions placed on the
   * {@code value}.
   *
   * @see StoredCell#updateValue(Object)
   */
  public void set(
      Metric%(dimensionality)d.CellKey<%(types)s> key,
      V value) {
    super.set(key, value);
  }

  /**
   * @see #set(Metric%(dimensionality)d.CellKey<%(types)s>, V)
   */
  public void set(
      %(params)s,
      V value) {
    // TODO(nsakharo): Move createCellKey() out of Metric classes.
    set(
        Metric%(dimensionality)d.createCellKey(
            %(values)s),
        value);
  }

  /**
   * Sets the value of the given cell to {@code value}, while setting the timestamp to
   * {@code timestampMicros}.
   *
   * Must be called only from the {@link CallbackTrigger} instance associated with the
   * metric - any calls outside of the trigger context will be ignored (and will result in
   * an exception if strict checking is enabled). Also, each cell should be set at most
   * once - while subsequent set() invocations for the same cell will succeed, they too
   * will result in an exception if strict checking is enabled.
   *
   * Setting timestamp explicitly is an advanced feature: use {@code #set(V)} instead
   * unless it really is necessary to do so. If timestamp is set explicitly, then ensure
   * that it is after the time when the corresponding metric was created: monitoring systems are
   * likely to discard data if timestamps are out of order.
   *
   * <p>Also see {@link StoredCell#updateValue(Object)} for restrictions placed on the
   * {@code value}.
   *
   * @see StoredCell#updateValue(Object)
   */
  public void set(
      Metric%(dimensionality)d.CellKey<%(types)s> key,
      V value,
      long timestampMicros) {
    super.set(key, value, timestampMicros);
  }

  /**
   * @see #set(Metric%(dimensionality)d.CellKey<%(types)s>, V, long)
   */
  public void set(
      %(params)s,
      V value,
      long timestampMicros) {
    set(
        Metric%(dimensionality)d.createCellKey(
            %(values)s),
        value,
        timestampMicros);
  }

  /**
   * Sets the value of the given cell to {@code value}, while setting the timestamp and
   * reset timestamp to {@code timestampMicros} and {@code resetTimestampMicros}, respectively.
   *
   * Must be called only from the {@link CallbackTrigger} instance associated with the
   * metric - any calls outside of the trigger context will be ignored (and will result in
   * an exception if strict checking is enabled). Also, each cell should be set at most
   * once - while subsequent set() invocations for the same cell will succeed, they too
   * will result in an exception if strict checking is enabled.
   *
   * Setting timestamps explicitly is an advanced feature: use {@code #set(V)} instead
   * unless it really is necessary to do so. If timestamps are set explicitly, then ensure
   * that timestamps and reset timestamps do not go backwards: monitoring systems are
   * likely to discard data if timestamps are out of order. It is an error for the reset
   * timestamp to be higher than the timestamp.
   *
   * <p>Also see {@link StoredCell#updateValue(Object)} for restrictions placed on the
   * {@code value}.
   *
   * @see StoredCell#updateValue(Object)
   */
  public void set(
      Metric%(dimensionality)d.CellKey<%(types)s> key,
      V value,
      long timestampMicros, long resetTimestampMicros) {
    super.set(key, value, timestampMicros, resetTimestampMicros);
  }

  /**
   * @see #set(Metric%(dimensionality)d.CellKey<%(types)s>, V, long, long)
   */
  public void set(
      %(params)s,
      V value,
      long timestampMicros, long resetTimestampMicros) {
    set(
        Metric%(dimensionality)d.createCellKey(
            %(values)s),
        value,
        timestampMicros, resetTimestampMicros);
  }
}