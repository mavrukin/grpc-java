// Copyright 2010 Google Inc. All Rights Reserved.
// Generated by generate.py

package io.grpc.monitoring.streamz.testing;

import com.google.common.base.Function;
import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;
import io.grpc.monitoring.streamz.Counter0;
import io.grpc.monitoring.streamz.Counter1;
import io.grpc.monitoring.streamz.Counter10;
import io.grpc.monitoring.streamz.Counter2;
import io.grpc.monitoring.streamz.Counter3;
import io.grpc.monitoring.streamz.Counter4;
import io.grpc.monitoring.streamz.Counter5;
import io.grpc.monitoring.streamz.Counter6;
import io.grpc.monitoring.streamz.Counter7;
import io.grpc.monitoring.streamz.Counter8;
import io.grpc.monitoring.streamz.Counter9;
import io.grpc.monitoring.streamz.Distribution;
import io.grpc.monitoring.streamz.EventMetric0;
import io.grpc.monitoring.streamz.EventMetric1;
import io.grpc.monitoring.streamz.EventMetric10;
import io.grpc.monitoring.streamz.EventMetric2;
import io.grpc.monitoring.streamz.EventMetric3;
import io.grpc.monitoring.streamz.EventMetric4;
import io.grpc.monitoring.streamz.EventMetric5;
import io.grpc.monitoring.streamz.EventMetric6;
import io.grpc.monitoring.streamz.EventMetric7;
import io.grpc.monitoring.streamz.EventMetric8;
import io.grpc.monitoring.streamz.EventMetric9;
import io.grpc.monitoring.streamz.Field;
import io.grpc.monitoring.streamz.GenericMetric;
import io.grpc.monitoring.streamz.Metric0;
import io.grpc.monitoring.streamz.Metric1;
import io.grpc.monitoring.streamz.Metric10;
import io.grpc.monitoring.streamz.Metric2;
import io.grpc.monitoring.streamz.Metric3;
import io.grpc.monitoring.streamz.Metric4;
import io.grpc.monitoring.streamz.Metric5;
import io.grpc.monitoring.streamz.Metric6;
import io.grpc.monitoring.streamz.Metric7;
import io.grpc.monitoring.streamz.Metric8;
import io.grpc.monitoring.streamz.Metric9;
import io.grpc.monitoring.streamz.MetricFactory;
import io.grpc.monitoring.streamz.VirtualMetric0;
import io.grpc.monitoring.streamz.VirtualMetric1;
import io.grpc.monitoring.streamz.VirtualMetric2;
import io.grpc.monitoring.streamz.VirtualMetric3;
import io.grpc.monitoring.streamz.VirtualMetric4;
import io.grpc.monitoring.streamz.VirtualMetric5;
import io.grpc.monitoring.streamz.VirtualMetric6;
import io.grpc.monitoring.streamz.VirtualMetric7;

import java.util.Map;

import javax.annotation.Generated;

/**
 * Utility for testing that {@code Metric}s are updated appropriately.
 * StreamzTester can test values of metrics either in-process, or in a
 * remote process, using {@link RemoteMetricReader}.
 *
 * @author ecurran@google.com (Eoin Curran)
 */
@Generated(value = "generate.py")
public class StreamzTester {

  private final Map<Class<? extends Enum<?>>, Function<String, ? extends Enum>> enumTranslators =
      Maps.newIdentityHashMap();
  private final MetricReader reader;

  /**
   * Creates a tester using a supplied MetricReader.
   */
  private StreamzTester(MetricReader reader) {
    this.reader = reader;
  }

  /**
   * Creates a tester, using streamz values in-process.
   */
  private StreamzTester() {
    this(new LocalMetricReader());
  }

  /**
   * Creates a tester, using streamz values in-process created by the supplied factory.
   */
  private StreamzTester(MetricFactory factory) {
    this(new LocalMetricReader(factory));
  }

  /**
   * Creates a StreamzTester that speaks to the Stubby service defined by the supplied serverSpec.
   */
  public static StreamzTester createRemoteTester(String serverSpec) {
    return new StreamzTester(new RemoteMetricReader(new RpcStubParameters(serverSpec)));
  }

  /**
   * Creates a StreamzTester that speaks to the Stubby service at the supplied host and port.
   */
  public static StreamzTester createRemoteTester(String host, int port) {
    return new StreamzTester(new RemoteMetricReader(new RpcStubParameters(host, port)));
  }

  /**
   * Creates a StreamzTester that speaks to the Stubby service on the supplied channel.
   */
  public static StreamzTester createRemoteTester(RpcChannel channel) {
    return new StreamzTester(new RemoteMetricReader(new RpcStubParameters(channel)));
  }

  /**
   * Creates a StreamzTester that speaks to the in-process metrics created by the supplied factory.
   *
   * @see MetricFactory
   * @see io.grpc.monitoring.streamz.TestMetricFactory
   */
  public static StreamzTester createLocalTester(MetricFactory factory) {
    return new StreamzTester(new LocalMetricReader(factory));
  }

  /**
   * Creates a StreamzTester that speaks to the in-process metrics created by the default factory.
   *
   * @see MetricFactory
   * @see MetricFactory#getDefault()
   */
  public static StreamzTester createLocalTesterForDefaultFactory() {
    return new StreamzTester();
  }

  /**
   * Map an enum to a class that restores values to their original enum type.
   *
   * <p>In most cases, it's possible to restore the original enum value from a snapshot by
   * using the inverse of the Enum's {@code toString} method. However in the case where the
   * specific enum class overrides toString, the enum can't be reverse identified. In those cases,
   * the tester can provide an inversion function, turning Strings to their original enum
   * values.
   * 
   * <p>Keep in mind that this API applies to metric <i>values</i> only, and does not
   * apply to metric fields. Enum fields are dealt with using {@link
   * io.grpc.monitoring.streamz.Field#ofEnumAsString(Class, String)}.
   *
   * @param cls the enum class to be supported. Calling this method repeatedly with the same
   * class will replace all previously defined translators.
   * @param function a function that restores an enum from its {@link Enum#toString()} form.
   * Passing {@code null} indicates that the class has no translator.
   *
   * @return this object, allowing method chaining.
   */
  public <T extends Enum<T>> StreamzTester addEnumTranslator(
      Class<T> cls, Function<String, T> function) {
    enumTranslators.put(cls, function);
    return this;
  }

  /**
   * Get the enum translator assocaited with this tester.
   */
  @SuppressWarnings("unchecked") // addEnumTranslator ensures the typecast is safe.
  <T extends Enum<T>> Function<String, T> getEnumTranslator(Class<T> c) {
    return (Function<String, T>) enumTranslators.get(c);
  }

  /**
   * Reads a snapshot of Streamz metrics matching the given pattern.
   *
   * @param pattern If pattern ends in a '/', then it will match all metrics
   *     with that prefix. Otherwise it matches metrics with exactly that name.
   */
  public StreamzSnapshot getSnapshot(String pattern) {
    return reader.snapshot(pattern);
  }

  /**
   * Reads a snapshot of all Streamz metrics.
   */
  public StreamzSnapshot getFullSnapshot() {
    return reader.snapshotAll();
  }

  /**
   * Creates a metric tester for a named metric.
   *
   * <p> <b>Important</b> When the metric's value type
   * {@code Integer}, use {@code Long} here. That's because the collection mechanism doesn't
   * distinguish between 32- and 64-bit integers, so the fact that the metric was an {@code
   * Integer} is long gone by the time this reference gets a hold of it.
   *
   * @param metricName name of the metric to create a tester for.
   * @param valueType the value type of the metric.
   */
  public <V> MetricReference0<V> metricReference(
      String metricName,
      Class<V> valueType) {
    return new MetricReference0<V>(this, metricName, valueType);
  }

  /**
   * Creates a metric tester for a single-cell event metric.
   *
   * @param metricName The name of the metric to create the tester for.
   */
  public MetricReference0<Distribution> eventMetricReference(
      String metricName) {
    return new MetricReference0<Distribution>(
        this, metricName, Distribution.class);
  }

  private <V, M extends GenericMetric<V, M>> MetricReference0<V> referenceToImpl0(
      GenericMetric<V, M> metric) {
    return new MetricReference0<V>(this, metric.getName(), metric.getValueType());
  }

  /**
   * Creates a metric tester for a specific metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <V> MetricReference0<V> referenceTo(Metric0<V> metric) {
    return referenceToImpl0(metric);
  }

  /**
   * Creates a metric tester for a specific event metric.
   *
   * @param metric the metric to create a tester for.
   */
  public MetricReference0<Distribution> referenceTo(EventMetric0 metric) {
    // Can't use referenceToImpl because getUnderlyingMetric() is protected.
    return new MetricReference0<Distribution>(this, metric.getName(), Distribution.class);
  }

  /**
   * Creates a metric tester for a specific counter.
   *
   * @param metric the metric to create a tester for.
   */
  public MetricReference0<Long> referenceTo(Counter0 metric) {
    return referenceToImpl0(metric);
  }

  /**
   * Creates a metric tester for a specific virtual metric.
   *
   * @param metric the metric to create a tester for.
   */
  public <V> MetricReference0<V> referenceTo(VirtualMetric0<V> metric) {
    return referenceToImpl0(metric);
  }


  /**
   * Creates a one-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @return The metric
   */
  public final <V, F1>
  Metric1<F1, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1) {
    Metric1<F1, V> metric =
        new Metric1<F1, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a one-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @return The metric
   */
  public final <V, F1>
  CallbackMetric1<F1, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1) {
    CallbackMetric1<F1, V> metric =
        new CallbackMetric1<F1, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a one-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @return The metric
   */
  public final <F1>
  Counter1<F1> newCounter(
      String name, Metadata metadata,
      Field<F1> field1) {
    Counter1<F1> metric =
        new Counter1<F1 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a one-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @return The metric
   */
  public final <F1>
  EventMetric1<F1> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1) {
    EventMetric1<F1> metric =
            new EventMetric1<F1>(
            name, bucketer, metadata,
            field1);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a one-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @return The metric
   */
  public final <F1>
  EventMetric1<F1> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1);
  }
  /**
   * Creates a two-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @return The metric
   */
  public final <V, F1, F2>
  Metric2<F1, F2, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2) {
    Metric2<F1, F2, V> metric =
        new Metric2<F1, F2, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a two-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @return The metric
   */
  public final <V, F1, F2>
  CallbackMetric2<F1, F2, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2) {
    CallbackMetric2<F1, F2, V> metric =
        new CallbackMetric2<F1, F2, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a two-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @return The metric
   */
  public final <F1, F2>
  Counter2<F1, F2> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2) {
    Counter2<F1, F2> metric =
        new Counter2<F1, F2 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a two-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @return The metric
   */
  public final <F1, F2>
  EventMetric2<F1, F2> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2) {
    EventMetric2<F1, F2> metric =
            new EventMetric2<F1, F2>(
            name, bucketer, metadata,
            field1,
            field2);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a two-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @return The metric
   */
  public final <F1, F2>
  EventMetric2<F1, F2> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2);
  }
  /**
   * Creates a three-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @return The metric
   */
  public final <V, F1, F2, F3>
  Metric3<F1, F2, F3, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3) {
    Metric3<F1, F2, F3, V> metric =
        new Metric3<F1, F2, F3, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a three-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @return The metric
   */
  public final <V, F1, F2, F3>
  CallbackMetric3<F1, F2, F3, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3) {
    CallbackMetric3<F1, F2, F3, V> metric =
        new CallbackMetric3<F1, F2, F3, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a three-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @return The metric
   */
  public final <F1, F2, F3>
  Counter3<F1, F2, F3> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3) {
    Counter3<F1, F2, F3> metric =
        new Counter3<F1, F2, F3 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a three-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @return The metric
   */
  public final <F1, F2, F3>
  EventMetric3<F1, F2, F3> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3) {
    EventMetric3<F1, F2, F3> metric =
            new EventMetric3<F1, F2, F3>(
            name, bucketer, metadata,
            field1,
            field2,
            field3);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a three-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @return The metric
   */
  public final <F1, F2, F3>
  EventMetric3<F1, F2, F3> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3);
  }
  /**
   * Creates a four-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4>
  Metric4<F1, F2, F3, F4, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4) {
    Metric4<F1, F2, F3, F4, V> metric =
        new Metric4<F1, F2, F3, F4, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a four-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4>
  CallbackMetric4<F1, F2, F3, F4, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4) {
    CallbackMetric4<F1, F2, F3, F4, V> metric =
        new CallbackMetric4<F1, F2, F3, F4, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a four-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @return The metric
   */
  public final <F1, F2, F3, F4>
  Counter4<F1, F2, F3, F4> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4) {
    Counter4<F1, F2, F3, F4> metric =
        new Counter4<F1, F2, F3, F4 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a four-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @return The metric
   */
  public final <F1, F2, F3, F4>
  EventMetric4<F1, F2, F3, F4> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4) {
    EventMetric4<F1, F2, F3, F4> metric =
            new EventMetric4<F1, F2, F3, F4>(
            name, bucketer, metadata,
            field1,
            field2,
            field3,
            field4);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a four-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @return The metric
   */
  public final <F1, F2, F3, F4>
  EventMetric4<F1, F2, F3, F4> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3,
            field4);
  }
  /**
   * Creates a five-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5>
  Metric5<F1, F2, F3, F4, F5, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5) {
    Metric5<F1, F2, F3, F4, F5, V> metric =
        new Metric5<F1, F2, F3, F4, F5, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a five-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5>
  CallbackMetric5<F1, F2, F3, F4, F5, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5) {
    CallbackMetric5<F1, F2, F3, F4, F5, V> metric =
        new CallbackMetric5<F1, F2, F3, F4, F5, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a five-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5>
  Counter5<F1, F2, F3, F4, F5> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5) {
    Counter5<F1, F2, F3, F4, F5> metric =
        new Counter5<F1, F2, F3, F4, F5 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a five-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5>
  EventMetric5<F1, F2, F3, F4, F5> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5) {
    EventMetric5<F1, F2, F3, F4, F5> metric =
            new EventMetric5<F1, F2, F3, F4, F5>(
            name, bucketer, metadata,
            field1,
            field2,
            field3,
            field4,
            field5);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a five-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5>
  EventMetric5<F1, F2, F3, F4, F5> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3,
            field4,
            field5);
  }
  /**
   * Creates a six-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6>
  Metric6<F1, F2, F3, F4, F5, F6, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6) {
    Metric6<F1, F2, F3, F4, F5, F6, V> metric =
        new Metric6<F1, F2, F3, F4, F5, F6, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a six-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6>
  CallbackMetric6<F1, F2, F3, F4, F5, F6, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6) {
    CallbackMetric6<F1, F2, F3, F4, F5, F6, V> metric =
        new CallbackMetric6<F1, F2, F3, F4, F5, F6, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a six-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6>
  Counter6<F1, F2, F3, F4, F5, F6> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6) {
    Counter6<F1, F2, F3, F4, F5, F6> metric =
        new Counter6<F1, F2, F3, F4, F5, F6 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a six-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6>
  EventMetric6<F1, F2, F3, F4, F5, F6> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6) {
    EventMetric6<F1, F2, F3, F4, F5, F6> metric =
            new EventMetric6<F1, F2, F3, F4, F5, F6>(
            name, bucketer, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a six-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6>
  EventMetric6<F1, F2, F3, F4, F5, F6> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6);
  }
  /**
   * Creates a seven-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7>
  Metric7<F1, F2, F3, F4, F5, F6, F7, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7) {
    Metric7<F1, F2, F3, F4, F5, F6, F7, V> metric =
        new Metric7<F1, F2, F3, F4, F5, F6, F7, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a seven-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7>
  CallbackMetric7<F1, F2, F3, F4, F5, F6, F7, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7) {
    CallbackMetric7<F1, F2, F3, F4, F5, F6, F7, V> metric =
        new CallbackMetric7<F1, F2, F3, F4, F5, F6, F7, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a seven-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7>
  Counter7<F1, F2, F3, F4, F5, F6, F7> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7) {
    Counter7<F1, F2, F3, F4, F5, F6, F7> metric =
        new Counter7<F1, F2, F3, F4, F5, F6, F7 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a seven-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7>
  EventMetric7<F1, F2, F3, F4, F5, F6, F7> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7) {
    EventMetric7<F1, F2, F3, F4, F5, F6, F7> metric =
            new EventMetric7<F1, F2, F3, F4, F5, F6, F7>(
            name, bucketer, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a seven-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7>
  EventMetric7<F1, F2, F3, F4, F5, F6, F7> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7);
  }
  /**
   * Creates a eight-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7, F8>
  Metric8<F1, F2, F3, F4, F5, F6, F7, F8, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8) {
    Metric8<F1, F2, F3, F4, F5, F6, F7, F8, V> metric =
        new Metric8<F1, F2, F3, F4, F5, F6, F7, F8, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a eight-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7, F8>
  CallbackMetric8<F1, F2, F3, F4, F5, F6, F7, F8, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8) {
    CallbackMetric8<F1, F2, F3, F4, F5, F6, F7, F8, V> metric =
        new CallbackMetric8<F1, F2, F3, F4, F5, F6, F7, F8, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a eight-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8>
  Counter8<F1, F2, F3, F4, F5, F6, F7, F8> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8) {
    Counter8<F1, F2, F3, F4, F5, F6, F7, F8> metric =
        new Counter8<F1, F2, F3, F4, F5, F6, F7, F8 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a eight-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8>
  EventMetric8<F1, F2, F3, F4, F5, F6, F7, F8> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8) {
    EventMetric8<F1, F2, F3, F4, F5, F6, F7, F8> metric =
            new EventMetric8<F1, F2, F3, F4, F5, F6, F7, F8>(
            name, bucketer, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a eight-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8>
  EventMetric8<F1, F2, F3, F4, F5, F6, F7, F8> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8);
  }
  /**
   * Creates a nine-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7, F8, F9>
  Metric9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9) {
    Metric9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V> metric =
        new Metric9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a nine-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7, F8, F9>
  CallbackMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9) {
    CallbackMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V> metric =
        new CallbackMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a nine-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8, F9>
  Counter9<F1, F2, F3, F4, F5, F6, F7, F8, F9> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9) {
    Counter9<F1, F2, F3, F4, F5, F6, F7, F8, F9> metric =
        new Counter9<F1, F2, F3, F4, F5, F6, F7, F8, F9 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a nine-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8, F9>
  EventMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9) {
    EventMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9> metric =
            new EventMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9>(
            name, bucketer, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a nine-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8, F9>
  EventMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9);
  }
  /**
   * Creates a ten-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @param field10 The tenth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>
  Metric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9,
      Field<F10> field10) {
    Metric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V> metric =
        new Metric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9,
            field10));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a ten-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @param field10 The tenth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>
  CallbackMetric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9,
      Field<F10> field10) {
    CallbackMetric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V> metric =
        new CallbackMetric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9,
            field10));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a ten-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @param field10 The tenth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>
  Counter10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9,
      Field<F10> field10) {
    Counter10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> metric =
        new Counter10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9,
            field10));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a ten-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @param field10 The tenth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>
  EventMetric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9,
      Field<F10> field10) {
    EventMetric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> metric =
            new EventMetric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>(
            name, bucketer, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9,
            field10);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a ten-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @param field10 The tenth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>
  EventMetric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9,
      Field<F10> field10) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9,
            field10);
  }
}