// Copyright 2010 Google Inc. All Rights Reserved.
// Generated by generate.py

package io.grpc.monitoring.streamz;

import com.google.common.base.Randoms;
import com.google.common.base.Supplier;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.inject.ProvidedBy;

import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

import javax.annotation.Generated;

/**
 * Factory for Streamz metrics.  To obtain the {@code MetricFactory} that
 * is used by Streamz to create metrics for export, use
 * {@link #getDefault()}.  For tests, see
 * {@link io.grpc.monitoring.streamz.TestMetricFactory}.
 *
 * <p>Examples:
 *
 * <pre>
 * // A temperature gauge: a Metric comprising a single stream of doubles.
 * private static final Metric0&lt;Double> temp = MetricFactory.getDefault().newMetric(
 *     "/hw/temperature", Double.class, new Metadata("The temperature in Kelvin"));
 *
 * temp.set(273.16); // brrr!
 * temp.set(373.16); // phew!
 *
 * // Counters of cache accesses: a metric of two integer streams, by a
 * // boolean, hit/miss.
 * Metric1&lt;Boolean, Integer> cacheCounters = metricFactory.newMetric(
 *     "/myservice/counters", Integer.class,
 *     new Metadata("Counters of cache accesses, keyed by hit/miss").setCumulative(),
 *     Field.ofBoolean("hit"));
 *
 * // Record a cache access:
 * boolean hit = cache.put(field, value) == null;
 * cacheCounters.increment(hit);
 *
 * // Reset both buckets:
 * cacheCounters.set(false, 0); // misses
 * cacheCounters.set(true, 0);  // hits
 * </pre>
 *
 * <p>Event metrics are a bridge between streams of events and time-series
 * monitoring.  EventMetric exports various aggregations about some
 * quantitative aspect (or "metric") of an event.  For example, the event might
 * be a network request and the metric might be its request latency in
 * milliseconds or its packet size in bytes.
 *
 * <p>EventMetric computes statistics such as the sample count, mean, total,
 * minimum, maximum and variance, and a histogram (with a customizable
 * bucketing function), and exports them to humans via the /streamz HTTP
 * servlet, and to monitoring tools via the Streamz RPC service.
 *
 * <p>Example usage:
 *
 * <pre>
 *   EventMetric0 requestBytes = metricFactory.newEventMetric(
 *       "/myservice/request_bytes", new Metadata("request size in bytes")));
 *
 *   // Provide sample data:
 *   requestBytes.record(16512);
 *   ...
 *   requestBytes.record(4096);
 *
 *   EventMetric1<Integer> latencyByResponseCode = metricFactory.newEventMetric(
 *       "/myservice/response_latency",
 *       new Metadata("response latency in ms"),
 *       Field.ofInteger("response_code"));
 *
 *   // Record statistics about a request:
 *   latencyByResponseCode.record(
 *       response.getStatusCode(),
 *       stopWatch.stop().elapsedMillis());
 * </pre>
 *
 * @author flooey@google.com (Adam Vartanian)
 */
@Generated(value = "generate.py")
@ProvidedBy(DefaultMetricFactoryProvider.class)
public abstract class MetricFactory {

  /**
   * Metric factory that registers all created metrics with the Streamz root.
   *
   * @author flooey@google.com (Adam Vartanian)
   */
  static class RootMetricFactory extends MetricFactory {

    private final Root root;

    RootMetricFactory(Root root) {
      this.root = root;
    }

    @Override
    void onCreate(GenericMetric<?, ?> metric) {
      root.add(metric);
    }

    @Override
    void applyToMetric(String name, Receiver<GenericMetric<Object, ?>> callback) {
      root.applyToMetric(name, callback);
    }

    @Override
    void applyToMetricsBeneath(String pattern, Receiver<GenericMetric<Object, ?>> callback) {
      root.applyToMetricsBeneath(pattern, callback);
    }

    @Override
    void applyToMetrics(Iterable<String> names, Receiver<GenericMetric<Object, ?>> callback) {
      root.applyToMetrics(names, callback);
    }

    @Override
    void applyToMetricMetadata(Receiver<GenericMetric<Object, ?>> callback) {
      root.applyToMetricMetadata(callback);
    }
  }

  /**
   * A globally unique identifier for the metric factory.
   */
  private final long id = Randoms.secureRandom().nextLong();

  /**
   * Incremented whenever there is a change in the set of metrics.
   */
  private AtomicInteger generation = new AtomicInteger();

  /**
   * Returns the default (production) metric factory.  For tests, see
   * {@link io.grpc.monitoring.streamz.TestMetricFactory}.
   */
  public static MetricFactory getDefault() {
    return Root.getDefault().getMetricFactory();
  }

  private void internalOnCreate(GenericMetric<?, ?> metric) {
    generation.incrementAndGet();
    onCreate(metric);
    Streamz.initialize();
  }

  /**
   * Called after a metric is created from this factory.  Subclasses should
   * override this method to respond to metrics being created.
   */
  abstract void onCreate(GenericMetric<?, ?> metric);

  /**
   * Applies the specified Receiver to the named metric, while holding the
   * namespace lock.  If the metric doesn't exist, a no-op.  {@code callback}
   * should not retain a reference to its argument once it completes.
   */
  abstract void applyToMetric(String name, Receiver<GenericMetric<Object, ?>> callback);

  /**
   * Applies the specified Receiver, while holding the namespace lock,
   * to all metrics whose names are "beneath" {@code directory},
   * according to the usual UNIX convention. {@code directory} must
   * have a trailing "/". {@code callback} should not retain a
   * reference to its argument once it completes.
   */
  abstract void applyToMetricsBeneath(String pattern, Receiver<GenericMetric<Object, ?>> callback);

  /**
   * Applies the specified Receiver, while holding the namespace lock, to all
   * metrics matching provided list of names. Names ending with trailing "/" (slash),
   * per usual UNIX conventions, will be considered to be {@code directory} names and
   * will rely on prefix matching instead.
   *
   * <p>{@code callback} should not retain a reference to its argument once it
   * completes.
   */
  abstract void applyToMetrics(Iterable<String> pattern,
      Receiver<GenericMetric<Object, ?>> callback);

  /**
   * For the purpose of reading only metric metadata, applies the specified Receiver to
   * all metrics while holding the namespace lock. No triggers are invoked before applying
   * the Receiver, and {@link GenericMetric#applyToEachCell} must not be called within
   * {@code callback}.
   *
   * <p>
   * {@code callback} should not retain a reference to its argument once it completes.
   */
  abstract void applyToMetricMetadata(Receiver<GenericMetric<Object, ?>> callback);

  /**
   * Returns the globally unique ID for the metric factory.
   */
  final long getId() { return id; }

  /**
   * Returns the generation, which is incremented whenever there is a change in the set of metrics.
   */
  final int getGeneration() { return generation.get(); }

  /**
   * Constructs a zero-dimensional Metric whose values may be of any type,
   * including Protocol Messages.
   *
   * <p>Note, for a Protocol Message to be used as the value type of a Metric,
   * it must have the MessageSet extension, for example:
   *
   * <pre>
   * import "net/proto2/bridge/proto/message_set.proto";
   * message Foo {
   *   extend proto2.bridge.MessageSet {
   *     optional Foo message_set_extension = 314159; // unique identifier
   *   }
   *   // ... rest of message ...
   * }
   * </pre>
   *
   * Constructs a zero-dimensional metric.
   * @param name the name of this metric.  Must conform to this extended
   *   regexp: (/[a-zA-Z0-9_-]+)+.  It should follow Streamz conventions: http://go/streamz-naming.
   * @param valueClass Must match &lt;V>. V must be one of
   *     Boolean, Float, Double, Integer, Long, String, Enum
   *     or a subtype of {@link com.google.protobuf.Message}.
   *     For {@link Distribution}, use {@link #newEventMetric(String, Metadata)}.
   * @param metadata The metric's Metadata: description and annotations.
   * @return The metric
   */
  public final <V> Metric0<V> newMetric(
      String name, Class<V> valueClass, Metadata metadata) {
    Metric0<V> metric = new Metric0<V>(name, ValueTypeTraits.getTraits(valueClass), metadata);
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a legacy one-dimensional Void-valued metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *     It should follow Streamz conventions: http://go/streamz-naming.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @return The metric
   */
  final <F1> Metric1<F1, Void> newLegacyVoidMetric(
      String name, Metadata metadata,
      Field<F1> field1) {
    Metric1<F1, Void> metric =
        new Metric1<F1, Void>(
            name, ValueTypeTraits.getLegacyVoidTrait(), metadata,
            ImmutableList.of(field1));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a zero-dimensional CallbackMetric.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *     It should follow Streamz conventions: http://go/streamz-naming.
   * @param valueClass see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @return The metric
   */
  public final <V> CallbackMetric0<V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata) {
    CallbackMetric0<V> metric =
        new CallbackMetric0<V>(name, ValueTypeTraits.getTraits(valueClass), metadata);
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a zero-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *     It should follow Streamz conventions: http://go/streamz-naming.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @return The metric
   */
  public final Counter0 newCounter(String name, Metadata metadata) {
    Counter0 metric = new Counter0(
        name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative());
    internalOnCreate(metric);

    /* Special case for zero-dimensional counters. */
    metric.incrementBy(0);
    return metric;
  }

  /**
   * Constructs an zero-dimensional EventMetric.
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *     It should follow Streamz conventions: http://go/streamz-naming.
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @return The metric
   */
  public final EventMetric0 newEventMetric(String name, Bucketer bucketer, Metadata metadata) {
    EventMetric0 metric = new EventMetric0(name, bucketer, metadata);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs an zero-dimensional EventMetric with default bucketer.
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *     It should follow Streamz conventions: http://go/streamz-naming.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @return The metric
   */
  public final EventMetric0 newEventMetric(String name, Metadata metadata) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata);
  }

  /**
   * Constructs a zero-dimensional VirtualMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *     It should follow Streamz conventions: http://go/streamz-naming.
   * @param valueClass Must match &lt;V>. see {@link #newMetric(String, Class, Metadata)}.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param supplier callback to supply the cell value.
   * @return The metric
   * @deprecated Use a CallbackMetric instead.
   */
  @Deprecated
  public final <V> VirtualMetric0<V> newMetric(
      String name, Class<V> valueClass, Metadata metadata, Supplier<V> supplier) {
    VirtualMetric0<V> metric = new VirtualMetric0<V>(
        name, ValueTypeTraits.getTraits(valueClass), metadata, supplier);
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Convenience constructor for simple Metrics (with no fields) whose value
   * never changes.  Such metrics are annotated CONSTANT.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *     It should follow Streamz conventions: http://go/streamz-naming.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. Will
   *     have setConstant() called on it before construction.
   * @param constantValue the Metric's sole value.
   *     Must be of class V, not a subclass.
   * @return The metric
   */
  public final <V> ConstantMetric<V> newConstant(
      String name, V constantValue, Metadata metadata) {
    // This is safe if the user obeys the 'Must be of class V, not a subclass.'
    // precondition.
    @SuppressWarnings("unchecked")
    Class<V> valueClass = (Class<V>) constantValue.getClass();
    ConstantMetric<V> metric = new ConstantMetric<V>(name, valueClass, constantValue,
        metadata.setConstant());
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a new {@link CallbackTrigger} instance, used to update one or more
   * {@link CallbackMetric} instances. The {@code CallbackTrigger} will be invoked
   * whenever the system needs to obtain the associated {@code CallbackMetric} values.
   * A single {@code CallbackTrigger} could be associated with multiple {@code CallbackMetric}
   * instances and vice versa - each {@code CallbackMetric} could be updated by multiple
   * triggers. For example,
   *
   * <pre>
   * final CallbackMetric0<Long> metric1 =
   *    factory.newCallbackMetric("/metric1", Long.class, metadata);
   * final CallbackMetric1<Long, String> metric2 =
   *     factory.newCallbackMetric("/metric2", Long.class, metadata);
   *
   * CallbackTrigger trigger = factory.newTrigger(metric1, metric2,
   *     new Runnable() {
   *       @Override public void run() {
   *         metric1.set(System.something());
   *         metric2.set("x", System.somethingElse());
   *       }
   *     });
   * </pre>
   *
   * @see CallbackTrigger for more information.
   *
   * @param trigger a Runnable that will be executed once per evaluation of all metrics
   *     associated with the CallbackTrigger instance. These metrics will accept new
   *     values only when invoked inside provided Runnable instance.
   * @return the new callback trigger instance
   */
  public final CallbackTrigger newTrigger(Set<? extends CallbackMetric<?, ?>> metrics,
      Runnable trigger) {
    // FIXME(nsakharo): Validate that all metrics belong to the same registry. Could be done
    // by adding onCreate(CallbackTrigger) method or by exposing MetricRegistry.getMetrics() all
    // the way to MetricFactory.
    CallbackTrigger callbackTrigger = new CallbackTrigger(trigger, metrics);
    callbackTrigger.register();
    return callbackTrigger;
  }

  /**
   * Creates a new {@link CallbackTrigger} instance associated with given metrics, providing
   * shortcut form for {@code MetricFactory.newTrigger(ImmutableSet.of(metric1, ...), trigger);}.
   *
   * See {@link MetricFactory#newTrigger(java.util.Set, java.lang.Runnable)} for more details.
   */
  public final CallbackTrigger newTrigger(CallbackMetric<?, ?> metric1,
      Runnable trigger) {
    return newTrigger(ImmutableSet.of(metric1), trigger);
  }

  /**
   * Creates a new {@link CallbackTrigger} instance associated with given metrics, providing
   * shortcut form for {@code MetricFactory.newTrigger(ImmutableSet.of(metric1, ...), trigger);}.
   *
   * See {@link MetricFactory#newTrigger(java.util.Set, java.lang.Runnable)} for more details.
   */
  public final CallbackTrigger newTrigger(CallbackMetric<?, ?> metric1,
      CallbackMetric<?, ?> metric2,
      Runnable trigger) {
    return newTrigger(ImmutableSet.of(metric1, metric2), trigger);
  }

  /**
   * Creates a new {@link CallbackTrigger} instance associated with given metrics, providing
   * shortcut form for {@code MetricFactory.newTrigger(ImmutableSet.of(metric1, ...), trigger);}.
   *
   * See {@link MetricFactory#newTrigger(java.util.Set, java.lang.Runnable)} for more details.
   */
  public final CallbackTrigger newTrigger(CallbackMetric<?, ?> metric1,
      CallbackMetric<?, ?> metric2,
      CallbackMetric<?, ?> metric3,
      Runnable trigger) {
    return newTrigger(ImmutableSet.of(metric1, metric2, metric3), trigger);
  }

  /**
   * Creates a new {@link CallbackTrigger} instance associated with given metrics, providing
   * shortcut form for {@code MetricFactory.newTrigger(ImmutableSet.of(metric1, ...), trigger);}.
   *
   * See {@link MetricFactory#newTrigger(java.util.Set, java.lang.Runnable)} for more details.
   */
  public final CallbackTrigger newTrigger(CallbackMetric<?, ?> metric1,
      CallbackMetric<?, ?> metric2,
      CallbackMetric<?, ?> metric3,
      CallbackMetric<?, ?> metric4,
      Runnable trigger) {
    return newTrigger(ImmutableSet.of(metric1, metric2, metric3, metric4), trigger);
  }

  /**
   * Creates a new {@link CallbackTrigger} instance associated with given metrics, providing
   * shortcut form for {@code MetricFactory.newTrigger(ImmutableSet.of(metric1, ...), trigger);}.
   *
   * See {@link MetricFactory#newTrigger(java.util.Set, java.lang.Runnable)} for more details.
   */
  public final CallbackTrigger newTrigger(CallbackMetric<?, ?> metric1,
      CallbackMetric<?, ?> metric2,
      CallbackMetric<?, ?> metric3,
      CallbackMetric<?, ?> metric4,
      CallbackMetric<?, ?> metric5,
      Runnable trigger) {
    return newTrigger(ImmutableSet.of(metric1, metric2, metric3, metric4, metric5), trigger);
  }

  /**
   * Creates a one-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *    It should follow Streamz conventions
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @return The metric
   */
  public final <V, F1>
  Metric1<F1, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1) {
    Metric1<F1, V> metric =
        new Metric1<F1, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a one-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @return The metric
   */
  public final <V, F1>
  CallbackMetric1<F1, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1) {
    CallbackMetric1<F1, V> metric =
        new CallbackMetric1<F1, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a one-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @return The metric
   */
  public final <F1>
  Counter1<F1> newCounter(
      String name, Metadata metadata,
      Field<F1> field1) {
    Counter1<F1> metric =
        new Counter1<F1 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a one-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @return The metric
   */
  public final <F1>
  EventMetric1<F1> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1) {
    EventMetric1<F1> metric =
            new EventMetric1<F1>(
            name, bucketer, metadata,
            field1);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a one-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @return The metric
   */
  public final <F1>
  EventMetric1<F1> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1);
  }
  /**
   * Creates a two-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *    It should follow Streamz conventions
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @return The metric
   */
  public final <V, F1, F2>
  Metric2<F1, F2, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2) {
    Metric2<F1, F2, V> metric =
        new Metric2<F1, F2, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a two-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @return The metric
   */
  public final <V, F1, F2>
  CallbackMetric2<F1, F2, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2) {
    CallbackMetric2<F1, F2, V> metric =
        new CallbackMetric2<F1, F2, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a two-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @return The metric
   */
  public final <F1, F2>
  Counter2<F1, F2> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2) {
    Counter2<F1, F2> metric =
        new Counter2<F1, F2 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a two-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @return The metric
   */
  public final <F1, F2>
  EventMetric2<F1, F2> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2) {
    EventMetric2<F1, F2> metric =
            new EventMetric2<F1, F2>(
            name, bucketer, metadata,
            field1,
            field2);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a two-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @return The metric
   */
  public final <F1, F2>
  EventMetric2<F1, F2> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2);
  }
  /**
   * Creates a three-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *    It should follow Streamz conventions
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @return The metric
   */
  public final <V, F1, F2, F3>
  Metric3<F1, F2, F3, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3) {
    Metric3<F1, F2, F3, V> metric =
        new Metric3<F1, F2, F3, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a three-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @return The metric
   */
  public final <V, F1, F2, F3>
  CallbackMetric3<F1, F2, F3, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3) {
    CallbackMetric3<F1, F2, F3, V> metric =
        new CallbackMetric3<F1, F2, F3, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a three-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @return The metric
   */
  public final <F1, F2, F3>
  Counter3<F1, F2, F3> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3) {
    Counter3<F1, F2, F3> metric =
        new Counter3<F1, F2, F3 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a three-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @return The metric
   */
  public final <F1, F2, F3>
  EventMetric3<F1, F2, F3> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3) {
    EventMetric3<F1, F2, F3> metric =
            new EventMetric3<F1, F2, F3>(
            name, bucketer, metadata,
            field1,
            field2,
            field3);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a three-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @return The metric
   */
  public final <F1, F2, F3>
  EventMetric3<F1, F2, F3> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3);
  }
  /**
   * Creates a four-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *    It should follow Streamz conventions
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4>
  Metric4<F1, F2, F3, F4, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4) {
    Metric4<F1, F2, F3, F4, V> metric =
        new Metric4<F1, F2, F3, F4, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a four-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4>
  CallbackMetric4<F1, F2, F3, F4, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4) {
    CallbackMetric4<F1, F2, F3, F4, V> metric =
        new CallbackMetric4<F1, F2, F3, F4, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a four-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @return The metric
   */
  public final <F1, F2, F3, F4>
  Counter4<F1, F2, F3, F4> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4) {
    Counter4<F1, F2, F3, F4> metric =
        new Counter4<F1, F2, F3, F4 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a four-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @return The metric
   */
  public final <F1, F2, F3, F4>
  EventMetric4<F1, F2, F3, F4> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4) {
    EventMetric4<F1, F2, F3, F4> metric =
            new EventMetric4<F1, F2, F3, F4>(
            name, bucketer, metadata,
            field1,
            field2,
            field3,
            field4);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a four-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @return The metric
   */
  public final <F1, F2, F3, F4>
  EventMetric4<F1, F2, F3, F4> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3,
            field4);
  }
  /**
   * Creates a five-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *    It should follow Streamz conventions
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5>
  Metric5<F1, F2, F3, F4, F5, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5) {
    Metric5<F1, F2, F3, F4, F5, V> metric =
        new Metric5<F1, F2, F3, F4, F5, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a five-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5>
  CallbackMetric5<F1, F2, F3, F4, F5, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5) {
    CallbackMetric5<F1, F2, F3, F4, F5, V> metric =
        new CallbackMetric5<F1, F2, F3, F4, F5, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a five-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5>
  Counter5<F1, F2, F3, F4, F5> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5) {
    Counter5<F1, F2, F3, F4, F5> metric =
        new Counter5<F1, F2, F3, F4, F5 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a five-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5>
  EventMetric5<F1, F2, F3, F4, F5> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5) {
    EventMetric5<F1, F2, F3, F4, F5> metric =
            new EventMetric5<F1, F2, F3, F4, F5>(
            name, bucketer, metadata,
            field1,
            field2,
            field3,
            field4,
            field5);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a five-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5>
  EventMetric5<F1, F2, F3, F4, F5> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3,
            field4,
            field5);
  }
  /**
   * Creates a six-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *    It should follow Streamz conventions
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6>
  Metric6<F1, F2, F3, F4, F5, F6, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6) {
    Metric6<F1, F2, F3, F4, F5, F6, V> metric =
        new Metric6<F1, F2, F3, F4, F5, F6, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a six-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6>
  CallbackMetric6<F1, F2, F3, F4, F5, F6, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6) {
    CallbackMetric6<F1, F2, F3, F4, F5, F6, V> metric =
        new CallbackMetric6<F1, F2, F3, F4, F5, F6, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a six-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6>
  Counter6<F1, F2, F3, F4, F5, F6> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6) {
    Counter6<F1, F2, F3, F4, F5, F6> metric =
        new Counter6<F1, F2, F3, F4, F5, F6 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a six-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6>
  EventMetric6<F1, F2, F3, F4, F5, F6> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6) {
    EventMetric6<F1, F2, F3, F4, F5, F6> metric =
            new EventMetric6<F1, F2, F3, F4, F5, F6>(
            name, bucketer, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a six-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6>
  EventMetric6<F1, F2, F3, F4, F5, F6> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6);
  }
  /**
   * Creates a seven-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *    It should follow Streamz conventions
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7>
  Metric7<F1, F2, F3, F4, F5, F6, F7, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7) {
    Metric7<F1, F2, F3, F4, F5, F6, F7, V> metric =
        new Metric7<F1, F2, F3, F4, F5, F6, F7, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a seven-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7>
  CallbackMetric7<F1, F2, F3, F4, F5, F6, F7, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7) {
    CallbackMetric7<F1, F2, F3, F4, F5, F6, F7, V> metric =
        new CallbackMetric7<F1, F2, F3, F4, F5, F6, F7, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a seven-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7>
  Counter7<F1, F2, F3, F4, F5, F6, F7> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7) {
    Counter7<F1, F2, F3, F4, F5, F6, F7> metric =
        new Counter7<F1, F2, F3, F4, F5, F6, F7 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a seven-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7>
  EventMetric7<F1, F2, F3, F4, F5, F6, F7> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7) {
    EventMetric7<F1, F2, F3, F4, F5, F6, F7> metric =
            new EventMetric7<F1, F2, F3, F4, F5, F6, F7>(
            name, bucketer, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a seven-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7>
  EventMetric7<F1, F2, F3, F4, F5, F6, F7> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7);
  }
  /**
   * Creates a eight-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *    It should follow Streamz conventions
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7, F8>
  Metric8<F1, F2, F3, F4, F5, F6, F7, F8, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8) {
    Metric8<F1, F2, F3, F4, F5, F6, F7, F8, V> metric =
        new Metric8<F1, F2, F3, F4, F5, F6, F7, F8, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a eight-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7, F8>
  CallbackMetric8<F1, F2, F3, F4, F5, F6, F7, F8, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8) {
    CallbackMetric8<F1, F2, F3, F4, F5, F6, F7, F8, V> metric =
        new CallbackMetric8<F1, F2, F3, F4, F5, F6, F7, F8, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a eight-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8>
  Counter8<F1, F2, F3, F4, F5, F6, F7, F8> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8) {
    Counter8<F1, F2, F3, F4, F5, F6, F7, F8> metric =
        new Counter8<F1, F2, F3, F4, F5, F6, F7, F8 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a eight-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8>
  EventMetric8<F1, F2, F3, F4, F5, F6, F7, F8> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8) {
    EventMetric8<F1, F2, F3, F4, F5, F6, F7, F8> metric =
            new EventMetric8<F1, F2, F3, F4, F5, F6, F7, F8>(
            name, bucketer, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a eight-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8>
  EventMetric8<F1, F2, F3, F4, F5, F6, F7, F8> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8);
  }
  /**
   * Creates a nine-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *    It should follow Streamz conventions
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7, F8, F9>
  Metric9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9) {
    Metric9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V> metric =
        new Metric9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a nine-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7, F8, F9>
  CallbackMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9) {
    CallbackMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V> metric =
        new CallbackMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a nine-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8, F9>
  Counter9<F1, F2, F3, F4, F5, F6, F7, F8, F9> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9) {
    Counter9<F1, F2, F3, F4, F5, F6, F7, F8, F9> metric =
        new Counter9<F1, F2, F3, F4, F5, F6, F7, F8, F9 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a nine-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8, F9>
  EventMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9) {
    EventMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9> metric =
            new EventMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9>(
            name, bucketer, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a nine-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8, F9>
  EventMetric9<F1, F2, F3, F4, F5, F6, F7, F8, F9> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9);
  }
  /**
   * Creates a ten-dimensional metric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   *    It should follow Streamz conventions
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @param field10 The tenth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>
  Metric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V> newMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9,
      Field<F10> field10) {
    Metric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V> metric =
        new Metric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9,
            field10));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a ten-dimensional {@code CallbackMetric}.
   *
   * <p>This metric cannot be used on its own. It must be used inside a {@link CallbackTrigger}.
   *
   * @see #newTrigger for an API example.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param valueClass Must match &lt;V>.
   *    see {@link #newMetric(String, Class, Metadata)} for allowed values.
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @param field10 The tenth field
   * @return The metric
   */
  public final <V, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>
  CallbackMetric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V> newCallbackMetric(
      String name, Class<V> valueClass, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9,
      Field<F10> field10) {
    CallbackMetric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V> metric =
        new CallbackMetric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, V>(
            name, ValueTypeTraits.getTraits(valueClass), metadata,
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9,
            field10));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Creates a ten-dimensional Counter.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}. A cumulative annotation
   * is added to this metric.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @param field10 The tenth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>
  Counter10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> newCounter(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9,
      Field<F10> field10) {
    Counter10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> metric =
        new Counter10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10 >(
            name, ValueTypeTraits.getTraits(Long.class), metadata.setCumulative(),
            ImmutableList.of(
                field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9,
            field10));
    internalOnCreate(metric);
    return metric;
  }

  /**
   * Constructs a ten-dimensional EventMetric.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param bucketer the bucketing function to be used for the histogram of the
   *   exported Distribution.
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @param field10 The tenth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>
  EventMetric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> newEventMetric(
      String name, Bucketer bucketer, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9,
      Field<F10> field10) {
    EventMetric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> metric =
            new EventMetric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>(
            name, bucketer, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9,
            field10);
    internalOnCreate(metric.getUnderlyingMetric());
    return metric;
  }

  /**
   * Constructs a ten-dimensional EventMetric with default bucketer.
   *
   * @param name see {@link #newMetric(String, Class, Metadata)}
   * @param metadata see {@link #newMetric(String, Class, Metadata)}
   * @param field1 The first field
   * @param field2 The second field
   * @param field3 The third field
   * @param field4 The fourth field
   * @param field5 The fifth field
   * @param field6 The sixth field
   * @param field7 The seventh field
   * @param field8 The eighth field
   * @param field9 The ninth field
   * @param field10 The tenth field
   * @return The metric
   */
  public final <F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>
  EventMetric10<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10> newEventMetric(
      String name, Metadata metadata,
      Field<F1> field1,
      Field<F2> field2,
      Field<F3> field3,
      Field<F4> field4,
      Field<F5> field5,
      Field<F6> field6,
      Field<F7> field7,
      Field<F8> field8,
      Field<F9> field9,
      Field<F10> field10) {
    return newEventMetric(name, Bucketer.DEFAULT, metadata,
            field1,
            field2,
            field3,
            field4,
            field5,
            field6,
            field7,
            field8,
            field9,
            field10);
  }
}