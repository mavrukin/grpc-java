// Generated by ${generator}

package io.grpc.monitoring.streamz;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;

import java.util.Set;

import javax.annotation.Generated;

/**
 * A ${number}-dimensional Metric. This provides access to {@link StoredCell}s,
 * indexed by field values in a type-safe manner.
 *
 * <p>This class may only be instantiated through a {@link MetricFactory}.
 *
${type_javadoc} * @param <V> The type of the values stored in metric cells.
 * @author ecurran@google.com (Eoin Curran)
 * @author avrukin@google.com (Adopted / Moved to gRPC & Open Source)
 */
@Generated(value = "${generator}")
public class Metric${dimensionality}<${types}, V>
    extends StoredMetric<V, Metric${dimensionality}<${types}, V>> {

  /**
   * @see #createCellKey(
   *      ${types_erased})
   */
  public static final class CellKey<${types}> extends FieldTuple {
    CellKey(${params}) {
      super(${values});
    }
  }

  /**
   * As a performance optimization, if you are updating a number of metrics or counters
   * that use the same set of fields, you can pre-create the cell key and
   * re-use it.
   */
  public static
      <${types}> CellKey<${types}>
      createCellKey(
          ${params}) {
    return new CellKey<${types}>(
        ${values});
  }

  Metric${dimensionality}(String name, ValueTypeTraits<V> traits, Metadata metadata,
      ImmutableList<? extends Field<?>> fields) {
    super(name, traits, metadata, fields);
    Preconditions.checkArgument(getNumFields() == ${dimensionality});
  }

  /**
   * @see StoredCell#updateValue(Object)
   */
  public void set(
      CellKey<${types}> key,
      V value) {
    super.set(key, value);
  }

  /**
   * @see StoredCell#updateValue(Object)
   */
  public void set(
      ${params},
      V value) {
    set(
        createCellKey(
            ${values}),
        value);
  }

  /**
   * @see StoredCell#getValue()
   */
  public V get(CellKey<${types}> key) {
    return super.get(key);
  }

  /**
   * @see StoredCell#getValue()
   */
  public V get(${params}) {
    return get(createCellKey(
        ${values}));
  }

  /**
   * @see StoredMetric#clear(FieldTuple)
   */
  public void clear(CellKey<${types}> key) {
    super.clear(key);
  }

  /**
   * @see StoredMetric#clear(FieldTuple)
   */
  public void clear(${params}) {
    clear(createCellKey(
        ${values}));
  }

  /**
   * @see StoredCell#increment()
   */
  public void increment(CellKey<${types}> key) {
    super.increment(key);
  }

  /**
   * @see StoredCell#increment()
   */
  public void increment(
      ${params}) {
    increment(createCellKey(
        ${values}));
  }

  /**
   * @see StoredCell#decrement()
   */
  public void decrement(CellKey<${types}> key) {
    super.decrement(key);
  }

  /**
   * @see StoredCell#decrement()
   */
  public void decrement(
      ${params}) {
    decrement(createCellKey(
        ${values}));
  }

  /**
   * @see StoredCell#incrementBy(Number)
   */
  public void incrementBy(
      CellKey<${types}> key, Number value) {
    super.incrementBy(key, value);
  }

  /**
   * @see StoredCell#incrementBy(Number)
   */
  public void incrementBy(
      ${params}, Number value) {
    incrementBy(
        createCellKey(
            ${values}),
        value);
  }

  /**
   * @see StoredCell#changeUnderLock(CellValueChanger)
   */
  public void changeUnderLock(
      ${params},
      CellValueChanger<V> valueChanger) {
    changeUnderLock(
        createCellKey(
            ${values}),
        valueChanger);
  }

  /**
   * @see StoredCell#changeUnderLock(CellValueChanger)
   */
  public void changeUnderLock(
      CellKey<${types}> key,
      CellValueChanger<V> valueChanger) {
    super.changeUnderLock(key, valueChanger);
  }

  /**
   * @see StoredMetric#keySet()
   */
  // We ensure that only FieldTuples created by createCellKey are used as keys in the map
  @SuppressWarnings("unchecked")
  @Override
  public Set<CellKey<${types}>> keySet() {
    return (Set<CellKey<${types}>>) super.keySet();
  }
}